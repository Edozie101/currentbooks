<HTML><HEAD><TITLE>maze generation functions</TITLE></HEAD><BODY><H2 ALIGN="center">Functions for cast member "maze generation" of castlib "mazes"</H2><P><PRE><KBD><A NAME="initcells"> </A>on initcells me<BR> -- create a blank maze<BR> pcells=&#091;&#093;<BR> repeat with i=1 to ph<BR> repeat with j=1 to pw<BR> -- eller mazes start with all walls down, others with all walls up<BR> if pgentype="Eller" or pgentype="Circular" then w=0<BR> else w=1<BR> pcells.add(&#091;#right:w,#up:w,#id:0&#093;)<BR> end repeat<BR> end repeat<BR>end<BR><HR><A NAME="initgeneration"> </A>on initgeneration me<BR> -- set up parameters for maze generation<BR> pgenerationdata=&#091;:&#093;<BR> pgenerationdata&#091;#done&#093;=0<BR> pgenerationdata&#091;#type&#093;=pgentype<BR> pgenerationdata&#091;#multi&#093;=pmulti<BR> case pgentype of<BR> "Recursive backtrack":<BR> pstart=1<BR> pgenerationdata&#091;#path&#093;=&#091;pstart&#093; -- path to current <A HREF="maze generation.html#cell">cell</A><BR> pcells&#091;pstart&#093;.id=1 -- we've reached the first <A HREF="maze generation.html#cell">cell</A><BR> nl=randomizelist(me.<A HREF="maze generation.html#neighbors">neighbors</A>(pstart)) -- calculate <A HREF="maze generation.html#neighbors">neighbors</A> of start <A HREF="maze generation.html#cell">cell</A><BR> pgenerationdata&#091;#neighborlist&#093;=&#091;nl&#093;<BR> "Prim":<BR> pstart=1<BR> pgenerationdata&#091;#in&#093;=&#091;pstart&#093; -- list of cells reached<BR> n=me.<A HREF="maze generation.html#neighbors">neighbors</A>(pstart)<BR> pgenerationdata&#091;#frontier&#093;=n -- list of reachable cells <BR> repeat with c in n<BR> pcells&#091;c&#093;.id=-1 -- reachable cells to be drawn gray<BR> end repeat<BR> <BR> pcells&#091;pstart&#093;.id=1<BR> "Kruskal":<BR> l=&#091;:&#093;<BR> -- start off with each <A HREF="maze generation.html#cell">cell</A> in its own region<BR> repeat with i=1 to pcells.count<BR> pcells&#091;i&#093;.id=i+1<BR> l&#091;"l"&(i+1)&#093;=&#091;i&#093;<BR> end repeat<BR> pgenerationdata&#091;#regions&#093;=l<BR> -- create random list of all walls<BR> w=&#091;&#093;<BR> repeat with i=1 to ph<BR> repeat with j=1 to pw-1<BR> w.add(&#091;me.<A HREF="maze generation.html#cell">cell</A>(&#091;j,i&#093;),me.<A HREF="maze generation.html#cell">cell</A>(&#091;j+1,i&#093;)&#093;)<BR> end repeat<BR> end repeat<BR> repeat with i=1 to ph-1<BR> repeat with j=1 to pw<BR> w.add(&#091;me.<A HREF="maze generation.html#cell">cell</A>(&#091;j,i&#093;),me.<A HREF="maze generation.html#cell">cell</A>(&#091;j,i+1&#093;)&#093;)<BR> end repeat<BR> end repeat<BR> pgenerationdata&#091;#walls&#093;=randomizelist(w)<BR> "Eller", "Circular":<BR> -- create first row<BR> pgenerationdata&#091;#currentRow&#093;=1<BR> pgenerationdata&#091;#currentID&#093;=1<BR> pgenerationdata&#091;#hfactor&#093;=0<BR> me.<A HREF="maze generation.html#ellerRow">ellerRow</A>()<BR> pgenerationdata&#091;#hfactor&#093;=phfactor<BR> <BR> end case<BR>end<BR><HR><A NAME="ellerRow"> </A>on ellerRow me<BR> -- create a new row for Eller's algorithm<BR> r=pgenerationdata.currentRow<BR> id=pgenerationdata.currentID<BR> hf=pgenerationdata.hfactor<BR> c=me.<A HREF="maze generation.html#cell">cell</A>(&#091;1,r&#093;) -- start on one end of the row<BR> -- add random walls between cells of row, giving each<BR> -- group its own id number<BR> repeat with i=1 to pw-1<BR> pcells&#091;c&#093;.id=id<BR> if random(1000)&#060;hf then <BR> id=id+1<BR> me.<A HREF="maze generation.html#addwall">addwall</A>(c,c+1)<BR> end if<BR> c=c+1<BR> end repeat<BR> pcells&#091;c&#093;.id=id<BR> -- for a circular maze, loop back to the first id number<BR> if pgenerationdata.type="Circular" then<BR> repeat with i=pw down to 1<BR> if pcells&#091;c&#093;.id=id then<BR> pcells&#091;c&#093;.id= pgenerationdata.currentID<BR> else<BR> exit repeat<BR> end if<BR> c=c-1<BR> end repeat<BR> end if<BR> -- store the new highest id<BR> pgenerationdata.currentID=id+1<BR>end <BR><HR><A NAME="continuegeneration"> </A>on continuegeneration me<BR> -- run a single step of the algorithm<BR> case pgenerationdata.type of<BR> "Recursive backtrack":<BR> -- find the current <A HREF="maze generation.html#cell">cell</A><BR> p=pgenerationdata&#091;#path&#093;<BR> nb=pgenerationdata&#091;#neighborlist&#093;<BR> currentcell=p&#091;p.count&#093;<BR> -- find its untried <A HREF="maze generation.html#neighbors">neighbors</A><BR> nl=nb&#091;nb.count&#093;<BR> found=0<BR> -- find a neighbor not yet reached<BR> repeat with <A HREF="maze generation.html#cell">cell</A> in nl<BR> if not pcells&#091;<A HREF="maze generation.html#cell">cell</A>&#093;.id then <BR> found=1<BR> p.add(<A HREF="maze generation.html#cell">cell</A>)<BR> nb.add(randomizelist(me.<A HREF="maze generation.html#neighbors">neighbors</A>(<A HREF="maze generation.html#cell">cell</A>)))<BR> pcells&#091;<A HREF="maze generation.html#cell">cell</A>&#093;.id=1 -- mark it as found<BR> me.<A HREF="maze generation.html#removewall">removewall</A>(<A HREF="maze generation.html#cell">cell</A>, currentCell)<BR> exit repeat<BR> end if<BR> end repeat<BR> if not found then -- no such neighbor: backtrack<BR> p.deleteat(p.count)<BR> nb.deleteat(nb.count)<BR> if p.count=0 then me.<A HREF="maze generation.html#madesimplyconnected">madesimplyconnected</A>() -- path complete<BR> end if<BR> return 1 <BR> "Prim":<BR> -- choose a random <A HREF="maze generation.html#cell">cell</A> on the frontier<BR> f=pgenerationdata.frontier<BR> r=random(f.count)<BR> c=f&#091;r&#093;<BR> pcells&#091;c&#093;.id=1 -- mark it as found<BR> f.deleteat(r) -- remove it from the frontier<BR> -- add its unfound <A HREF="maze generation.html#neighbors">neighbors</A> to the frontier<BR> -- and for some found neighbor, remove the wall<BR> -- between them<BR> nl=randomizelist(me.<A HREF="maze generation.html#neighbors">neighbors</A>(c)) <BR> carved=0<BR> repeat with n in nl<BR> if pcells&#091;n&#093;.id=1 and not carved then<BR> me.<A HREF="maze generation.html#removewall">removewall</A>(c,n)<BR> carved=1<BR> else if pcells&#091;n&#093;.id=0 then<BR> pcells&#091;n&#093;.id=-1<BR> f.add(n)<BR> end if<BR> end repeat<BR> if f.count=0 then me.<A HREF="maze generation.html#madesimplyconnected">madesimplyconnected</A>() -- frontier is empty: maze complete<BR> return 1<BR> "Kruskal":<BR> -- choose a wall at random (they're already randomized)<BR> w=pgenerationdata.walls<BR> wl=w&#091;w.count&#093;<BR> w.deleteat(w.count)<BR> -- check the id of the two cells on either side<BR> id1=pcells&#091;wl&#091;1&#093;&#093;.id<BR> id2=pcells&#091;wl&#091;2&#093;&#093;.id<BR> if id1&#060;&#062;id2 then -- separate regions: join them<BR> il=pgenerationdata.regions&#091;"l"&id2&#093;<BR> ilt=pgenerationdata.regions&#091;"l"&id1&#093;<BR> me.<A HREF="maze generation.html#removewall">removewall</A>(wl&#091;1&#093;,wl&#091;2&#093;)<BR> repeat with c in il<BR> pcells&#091;c&#093;.id=id1 -- rename the cells to have the same id<BR> ilt.add(c) -- add them to one region<BR> end repeat<BR> pgenerationdata.regions.deleteprop("l"&id2) -- remove the other region<BR> if pgenerationdata.regions.count=1 then me.<A HREF="maze generation.html#madesimplyconnected">madesimplyconnected</A>() -- only one region: we're done<BR> end if<BR> return 1<BR> "Eller", "Circular":<BR> -- create a new row<BR> r=pgenerationdata.currentRow<BR> pgenerationdata.currentRow=r+1<BR> n=me.<A HREF="maze generation.html#cell">cell</A>(&#091;1,r+1&#093;)-1 -- last <A HREF="maze generation.html#cell">cell</A> of current row<BR> if pgenerationdata.type="Circular" then<BR> -- increase number of walls for each row in a circular maze<BR> pgenerationdata.hfactor=integer(pgenerationdata.hfactor*1.1)<BR> end if<BR> <BR> me.<A HREF="maze generation.html#ellerRow">ellerRow</A>()<BR> -- set t to a random list of squares in the row<BR> t=&#091;&#093;<BR> repeat with i=1 to pw<BR> t.add(i)<BR> end repeat<BR> t=randomizelist(t)<BR> repeat with i in t<BR> c=me.<A HREF="maze generation.html#cell">cell</A>(&#091;i,r&#093;)<BR> id1=pcells&#091;c&#093;.id -- id of <A HREF="maze generation.html#cell">cell</A> i in current row<BR> id2=pcells&#091;c+pw&#093;.id -- id of <A HREF="maze generation.html#cell">cell</A> i in new row<BR> if id1&#060;&#062;id2 then <BR> -- set all cells in new row with id2 to have id1<BR> repeat with j=1 to pw<BR> if pcells&#091;n+j&#093;.id=id2 then pcells&#091;n+j&#093;.id=id1<BR> end repeat<BR> -- set all cells in old row with id2 to have id1<BR> repeat with j=1 to pw<BR> if pcells&#091;n-pw+j&#093;.id=id2 then pcells&#091;n-pw+j&#093;.id=id1<BR> end repeat<BR> else<BR> -- this region has already been connected: add a wall<BR> me.<A HREF="maze generation.html#addwall">addwall</A>(c,c+pw)<BR> end if<BR> end repeat<BR> -- if this is the last wall, connect any regions that are still separate<BR> if r+1=ph then<BR> l=&#091;pcells&#091;n+1&#093;.id&#093;<BR> repeat with i=2 to pw<BR> if not l.getone(pcells&#091;n+i&#093;.id) then<BR> me.<A HREF="maze generation.html#removewall">removewall</A>(n+i-1,n+i)<BR> l.add(pcells&#091;n+i&#093;.id)<BR> end if<BR> end repeat<BR> me.<A HREF="maze generation.html#madesimplyconnected">madesimplyconnected</A>() -- we're done<BR> end if<BR> return 1<BR> "Multi":<BR> -- choose some walls at random<BR> l=&#091;&#093;<BR> sort l<BR> -- find the length of the shortest path from <BR> -- one side of the wall to the other<BR> repeat while l.count&#060;11<BR> sq=random(pcells.count)<BR> n=me.<A HREF="maze generation.html#neighbors">neighbors</A>(sq)<BR> sq2=n&#091;random(n.count)&#093;<BR> if me.<A HREF="maze generation.html#doorway">doorway</A>(sq, sq2,1) then next repeat<BR> path=astar(me,sq, sq2)<BR> if stringp(path) then next repeat -- shouldn't happen<BR> path.deleteat(1)<BR> l.add(path)<BR> end repeat<BR> -- pick the path of longest length<BR> path=l&#091;l.count&#093;<BR> -- remove the wall between the start and end squares<BR> me.<A HREF="maze generation.html#removewall">removewall</A>(path&#091;2&#093;,path&#091;path.count&#093;)<BR> pgenerationdata.steps=pgenerationdata.steps-1<BR> me.<A HREF="maze generation.html#unhighlightpath">unhighlightpath</A>(pgenerationdata.lastpath)<BR> <BR> if pgenerationdata.steps=0 then pgenerationdata.done=1<BR> else<BR> path.deleteat(1)<BR> pgenerationdata.lastpath=path<BR> me.<A HREF="maze generation.html#highlightpath">highlightpath</A>(path)<BR> end if<BR> <BR> return 1<BR> end case<BR>end <BR><HR><A NAME="neighbors"> </A>on neighbors me, <A HREF="maze generation.html#cell">cell</A>, acc<BR> -- list of all neighbors of a particular <A HREF="maze generation.html#cell">cell</A><BR> c=me.<A HREF="maze generation.html#coords">coords</A>(<A HREF="maze generation.html#cell">cell</A>)<BR> l=&#091;&#093;<BR> if c&#091;1&#093;&#062;1 then l.add(me.<A HREF="maze generation.html#cell">cell</A>(c-&#091;1,0&#093;))<BR> if c&#091;2&#093;&#062;1 then l.add(me.<A HREF="maze generation.html#cell">cell</A>(c-&#091;0,1&#093;))<BR> if c&#091;1&#093;&#060;pw then l.add(me.<A HREF="maze generation.html#cell">cell</A>(c+&#091;1,0&#093;))<BR> if c&#091;2&#093;&#060;ph then l.add(me.<A HREF="maze generation.html#cell">cell</A>(c+&#091;0,1&#093;))<BR> if not acc then return l<BR> repeat with i=l.count down to 1<BR> if not me.<A HREF="maze generation.html#doorway">doorway</A>(<A HREF="maze generation.html#cell">cell</A>,l&#091;i&#093;,1) then l.deleteat(i)<BR> end repeat<BR> return l<BR>end<BR><HR><A NAME="getPropertyDescriptionList"> </A>on getpropertydescriptionlist me<BR> -- user-defined properties<BR> l=&#091;:&#093;<BR> l&#091;#pgentype&#093;=&#091;#comment:"Generation algorithm",#format:#string,#default:"Recursive backtrack",#range:&#091;"Recursive backtrack","Prim","Kruskal","Eller","Circular"&#093;&#093;<BR> l&#091;#pw&#093;=&#091;#comment:"Width",#format:#integer,#default:20&#093;<BR> l&#091;#ph&#093;=&#091;#comment:"Height",#format:#integer,#default:20&#093;<BR> l&#091;#psize&#093;=&#091;#comment:"Grid size in pixels",#format:#integer,#default:10&#093;<BR> l&#091;#panimate&#093;=&#091;#comment:"Animate generation?",#format:#boolean,#default:1&#093;<BR> l&#091;#phfactor&#093;=&#091;#comment:"Horizontal random factor (Eller)",#format:#integer,#default:500,#range:&#091;#min:1,#max:1000&#093;&#093;<BR> l&#091;#pmulti&#093;=&#091;#comment:"Multiplicity",#format:#integer,#default:0,#range:&#091;#min:0,#max:20&#093;&#093;<BR> return l<BR>end<BR><HR><A NAME="beginSprite"> </A>on beginsprite me<BR> psprite=sprite(me.spritenum)<BR> pmember=psprite.member<BR> pmember.name=pgentype<BR> me.<A HREF="maze generation.html#generatenew">generatenew</A>()<BR>end<BR><HR><A NAME="generatenew"> </A>on generatenew me<BR> -- create a blank maze<BR> me.<A HREF="maze generation.html#initcells">initcells</A>()<BR> -- start the maze generation going<BR> me.<A HREF="maze generation.html#initgeneration">initgeneration</A>()<BR> -- if not animating then run to completion<BR> if not panimate then<BR> repeat while not pgenerationdata.done<BR> me.<A HREF="maze generation.html#continuegeneration">continuegeneration</A>()<BR> end repeat<BR> me.<A HREF="maze generation.html#finishedmaze">finishedmaze</A>()<BR> end if<BR>end<BR><HR><A NAME="madesimplyconnected"> </A>on madesimplyconnected me<BR> -- runs when the simply connected maze is made<BR> if not pgenerationdata.multi then<BR> -- finished<BR> pgenerationdata.done=1<BR> else<BR> -- start multiple connection algorithm<BR> pgenerationdata.type="Multi"<BR> pgenerationdata&#091;#steps&#093;=pmulti<BR> pgenerationdata&#091;#lastpath&#093;=&#091;&#093;<BR> end if<BR>end<BR><HR><A NAME="finishedmaze"> </A>on finishedmaze me<BR> me.<A HREF="maze generation.html#drawmaze">drawmaze</A>()<BR> sendallsprites(#mazedone)<BR>end<BR><HR><A NAME="enterFrame"> </A>on enterframe me<BR> -- if animating, run the next step of the algorithm<BR> if not pgenerationdata.done then<BR> if me.<A HREF="maze generation.html#continuegeneration">continuegeneration</A>() then me.<A HREF="maze generation.html#drawmaze">drawmaze</A>()<BR> if pgenerationdata.done then me.<A HREF="maze generation.html#finishedmaze">finishedmaze</A>()<BR> end if<BR>end<BR><HR><A NAME="highlightpath"> </A>on highlightpath me, p, upd<BR> -- display all cells in a path<BR> repeat with i=1 to p.count<BR> s=p&#091;i&#093;<BR> if i=1 or i=p.count then pcells&#091;s&#093;.id=0<BR> else pcells&#091;s&#093;.id=-1<BR> end repeat<BR> if upd then me.<A HREF="maze generation.html#drawmaze">drawmaze</A>()<BR>end<BR><HR><A NAME="unhighlightpath"> </A>on unhighlightpath me, p, upd<BR> -- unhighlight all cells in a path<BR> repeat with i=1 to p.count<BR> s=p&#091;i&#093;<BR> pcells&#091;s&#093;.id=1<BR> end repeat<BR> if upd then me.<A HREF="maze generation.html#drawmaze">drawmaze</A>()<BR>end<BR><HR><A NAME="drawmaze"> </A>on drawmaze me<BR> -- draw the maze into an image<BR> if pgentype&#060;&#062;"Circular" then<BR> im=image(pw*psize,ph*psize,16)<BR> im.draw(im.rect,&#091;#shapetype:#rect,#color:rgb(0,0,0)&#093;)<BR> repeat with i=1 to ph<BR> repeat with j=1 to pw<BR> c=(i-1)*pw+j<BR> <A HREF="maze generation.html#cell">cell</A>=pcells&#091;c&#093;<BR> if <A HREF="maze generation.html#cell">cell</A>.id=0 then im.fill((j-1)*psize+1,(i-1)*psize+1,j*psize,i*psize,rgb(150,150,150))<BR> else if <A HREF="maze generation.html#cell">cell</A>.id=-1 then im.fill((j-1)*psize+1,(i-1)*psize+1,j*psize,i*psize,rgb(200,200,200))<BR> if j&#060;pw then<BR> if <A HREF="maze generation.html#cell">cell</A>.right then im.draw(j*psize,(i-1)*psize,j*psize,i*psize,rgb(0,0,0))<BR> end if<BR> if i&#060;ph then<BR> if <A HREF="maze generation.html#cell">cell</A>.up then im.draw((j-1)*psize,i*psize,j*psize,i*psize,rgb(0,0,0))<BR> end if<BR> end repeat<BR> end repeat<BR> else<BR> im=image(psize*(ph+2)*2,psize*(ph+2)*2,16)<BR> ang=2*pi/pw<BR> angm=ang/10<BR> c=point(im.width/2,im.height/2)<BR> repeat with i=1 to ph<BR> r=psize*(i+2)<BR> c1=point(0,1)<BR> repeat with j=1 to pw<BR> cl=(i-1)*pw+j<BR> <A HREF="maze generation.html#cell">cell</A>=pcells&#091;cl&#093;<BR> c2=point(sin(ang*j),cos(ang*j))<BR> if <A HREF="maze generation.html#cell">cell</A>.right then im.draw(c2*r+c,c2*(r-psize)+c,rgb(0,0,0))<BR> repeat with k=1 to 10<BR> a=ang*(j-1)+angm*k<BR> c3=point(sin(a),cos(a))<BR> if i=ph or <A HREF="maze generation.html#cell">cell</A>.up or (k&#060;i and (k&#060;10 or (k&#060;9 and i&#060;15))) then <BR> im.draw(c1*r+c,c3*r+c,rgb(0,0,0))<BR> end if<BR> <BR> c1=c3<BR> end repeat<BR> c1=c2<BR> end repeat<BR> end repeat<BR> <BR> end if<BR> <BR> pmember.image=im<BR>end<BR><HR><A NAME="coords"> </A>on coords me, <A HREF="maze generation.html#cell">cell</A><BR> -- find <A HREF="maze generation.html#cell">cell</A> coordinates<BR> x=<A HREF="maze generation.html#cell">cell</A> mod pw<BR> if x=0 then x=pw<BR> y=1+(<A HREF="maze generation.html#cell">cell</A>-x)/pw<BR> return &#091;x,y&#093;<BR>end<BR><HR><A NAME="cell"> </A>on cell me, <A HREF="maze generation.html#coords">coords</A><BR> -- find cell number<BR> if <A HREF="maze generation.html#coords">coords</A>&#091;2&#093;&#060;1 or <A HREF="maze generation.html#coords">coords</A>&#091;1&#093;&#060;1 or <A HREF="maze generation.html#coords">coords</A>&#091;1&#093;&#062;pw or <A HREF="maze generation.html#coords">coords</A>&#091;2&#093;&#062;ph then return 0<BR> return (<A HREF="maze generation.html#coords">coords</A>&#091;2&#093;-1)*pw+<A HREF="maze generation.html#coords">coords</A>&#091;1&#093;<BR>end<BR><HR><A NAME="removewall"> </A>on removewall me, cell1, cell2<BR> if cell2=cell1+1 then<BR> pcells&#091;cell1&#093;.right=0<BR> else if cell1=cell2+1 then<BR> pcells&#091;cell2&#093;.right=0<BR> else if cell2=cell1+pw then<BR> pcells&#091;cell1&#093;.up=0<BR> else if cell1=cell2+pw then<BR> pcells&#091;cell2&#093;.up=0<BR> end if<BR>end<BR><HR><A NAME="addwall"> </A>on addwall me, cell1, cell2<BR> if cell2=cell1+1 then<BR> pcells&#091;cell1&#093;.right=1<BR> else if cell1=cell2+1 then<BR> pcells&#091;cell2&#093;.right=1<BR> else if cell2=cell1+pw then<BR> pcells&#091;cell1&#093;.up=1<BR> else if cell1=cell2+pw then<BR> pcells&#091;cell2&#093;.up=1<BR> end if<BR>end<BR><HR><A NAME="getfactor"> </A>on getfactor me<BR> if pgentype="Eller" then return phfactor<BR>end<BR><HR><A NAME="updatefactor"> </A>on updatefactor me, v<BR> if pgentype="Eller" then phfactor=v<BR>end<BR><HR><A NAME="getmaze"> </A>on getmaze me<BR> return pcells.duplicate()<BR>end<BR><HR><A NAME="isdone"> </A>on isdone me<BR> return pgenerationdata.done<BR>end<BR><HR><A NAME="squarerect"> </A>on squarerect me, <A HREF="maze generation.html#cell">cell</A><BR> -- rect of a particular <A HREF="maze generation.html#cell">cell</A><BR> c=me.<A HREF="maze generation.html#coords">coords</A>(<A HREF="maze generation.html#cell">cell</A>)<BR> j=c&#091;1&#093;<BR> i=c&#091;2&#093;<BR> return rect((j-1)*psize+1,(i-1)*psize+1,j*psize,i*psize)<BR>end<BR><HR><A NAME="pointToSquare"> </A>on pointtosquare me, pt<BR> -- for a point in a square maze, returns the <A HREF="maze generation.html#cell">cell</A><BR> i=ceil(pt&#091;1&#093;/float(psize))<BR> j=ceil(pt&#091;2&#093;/float(psize))<BR> return me.<A HREF="maze generation.html#cell">cell</A>(&#091;i,j&#093;)<BR>end<BR><HR><A NAME="doorway"> </A>on doorway me, cell1, cell2, acc<BR> -- returns the coordinates of the doorway between<BR> -- two cells, in clockwise order, or 0 if there is<BR> -- none. If acc is 1, then just returns 1 if there<BR> -- is a doorway, 0 otherwise<BR> c1=me.<A HREF="maze generation.html#coords">coords</A>(cell1)<BR> c2=me.<A HREF="maze generation.html#coords">coords</A>(cell2)<BR> if cell2=cell1+1 then<BR> if pcells&#091;cell1&#093;.right=1 then return 0<BR> p1=c1<BR> p2=c1-&#091;0,1&#093;<BR> else if cell1=cell2+1 then<BR> if pcells&#091;cell2&#093;.right=1 then return 0<BR> p1=c2-&#091;0,1&#093;<BR> p2=c2<BR> <BR> else if cell2=cell1+pw then<BR> if pcells&#091;cell1&#093;.up=1 then return 0<BR> p1=c1-&#091;1,0&#093;<BR> p2=c1<BR> else if cell1=cell2+pw then<BR> if pcells&#091;cell2&#093;.up=1 then return 0<BR> p1=c2<BR> p2=c2-&#091;1,0&#093;<BR> <BR> end if<BR> if acc then return 1<BR> return &#091;point(p1&#091;1&#093;,p1&#091;2&#093;),point(p2&#091;1&#093;,p2&#091;2&#093;)&#093;*psize<BR>end<BR><HR><A NAME="straightDistance"> </A>on straightDistance me, cell1, cell2<BR> -- actually the squared distance<BR> c1=me.<A HREF="maze generation.html#coords">coords</A>(cell1)<BR> c2=me.<A HREF="maze generation.html#coords">coords</A>(cell2)<BR> c=c1-c2<BR> return c&#091;1&#093;*c&#091;1&#093;+c&#091;2&#093;*c&#091;2&#093;<BR>end<BR><HR></KBD><P><A HREF="mazes index.html">Back to index</A></PRE></BODY></HTML> 