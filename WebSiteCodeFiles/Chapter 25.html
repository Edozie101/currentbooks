<HTML><HEAD><TITLE>Chapter 25 (Game theory) functions</TITLE></HEAD><BODY><H2 ALIGN="center">Functions for cast member "Chapter 25 (Game theory)" of castlib "math"</H2><P><PRE><KBD><A NAME="makeTTTlist"> </A>on maketttlist n<BR> --! ARGUMENTS: n (a number, probably 9)<BR> --! RETURNS: A list of all possible game boards for a 2-player game with n cells<BR> <BR> set blist to &#091;&#093;<BR> repeat with i=0 to 5<BR> -- set b to an array of n 0's<BR> set b to &#091;&#093;<BR> b&#091;n&#093;=0<BR> if i=0 then<BR> blist.add(b)<BR> next repeat<BR> end if<BR> -- find the list of all possible boards with i 1's<BR> set bl to <A HREF="Chapter 25.html#boardlist">boardlist</A>(b, 1, i, 1)<BR> repeat with j=i-1 to i<BR> repeat with b in bl<BR> -- find the list of all possible boards with either i or i-1 2's<BR> set bl2 to <A HREF="Chapter 25.html#boardlist">boardlist</A>(b, 2, j, 1)<BR> repeat with bd in bl2<BR> blist.add(bd)<BR> end repeat<BR> end repeat<BR> end repeat<BR> end repeat<BR> return blist<BR>end<BR><HR><A NAME="makeTTTtree"> </A>on makeTTTtree n, blist<BR> --! ARGUMENTS: n (a number, probably 9), blist (output of <A HREF="Chapter 25.html#makeTTTlist">makeTTTlist</A>)<BR> --! RETURNS: a tree of all possible moves within blist<BR> <BR> -- the resulting array is two-dimensional,<BR> -- listing for each element its possible parents <BR> -- and then its children<BR> <BR> set tree to &#091;&#093;<BR> set e to &#091;&#091;&#093;,&#091;&#093;&#093;<BR> <BR> -- add as many copies of e to tree as the elements of blist<BR> repeat with i=1 to blist.count<BR> tree.add(e.duplicate())<BR> end repeat<BR> <BR> repeat with i=1 to blist.count<BR> set b to blist&#091;i&#093;<BR> if not b.getone(1) then next repeat -- empty board<BR> <BR> -- work out whose move it is by counting 0's<BR> syms=0<BR> repeat with j=1 to n<BR> if b&#091;j&#093;&#062;0 then syms=syms+1<BR> end repeat<BR> <BR> if syms mod 2 = 1 then -- O's turn<BR> set s to 1<BR> else -- X's turn<BR> set s to 2<BR> end if<BR> <BR> -- find all possible parents<BR> repeat with j=1 to n<BR> if b&#091;j&#093;=s then<BR> set p to b.duplicate()<BR> p&#091;j&#093;=0<BR> set k to blist.getPos(p) -- the position of p in blist<BR> tree&#091;k&#093;&#091;2&#093;.add(i)<BR> tree&#091;i&#093;&#091;1&#093;.add(k)<BR> end if<BR> <BR> end repeat<BR> end repeat<BR> <BR> return tree<BR>end <BR><HR><A NAME="boardlist"> </A>on boardlist (board, sym, n, start)<BR> --! ARGUMENTS: board (a list), sym (element with which to populate the list), <BR> --! n (number of elements to add), start (starting position within board<BR> --! RETURNS: a list of all possible boards filled with n copies of sym<BR> <BR> if n=0 then return &#091;board&#093;<BR> set bl to &#091;&#093;<BR> -- set c to the number of 0's in board<BR> set c to 0<BR> if voidp(start) then set start to 1<BR> repeat with i=start to board.count<BR> if board&#091;i&#093;=0 then set c to c+1<BR> end repeat<BR> -- find all possible positions for the first 0 to set to a sym<BR> set k to start-1<BR> repeat with i=1 to c-n+1<BR> set b to board.duplicate()<BR> -- set k to the position of the next 0<BR> repeat while true<BR> set k to k+1<BR> if b&#091;k&#093;=0 then exit repeat<BR> end repeat<BR> -- set this to a sym<BR> set b&#091;k&#093; to sym<BR> -- now find all boards with n-1 syms past position k<BR> set bls to boardlist(b, sym, n-1, k+1)<BR> -- and add them all to bl<BR> repeat with b in bls<BR> bl.add(b)<BR> end repeat<BR> <BR> end repeat<BR> return bl<BR>end <BR><HR><A NAME="makeMinimaxStrategy"> </A>on makeMinimaxStrategy (tree, bl, pruned)<BR> --! ARGUMENTS: tree (output of <A HREF="Chapter 25.html#makeTTTtree">makeTTTtree</A>), bl (output of <A HREF="Chapter 25.html#makeTTTlist">makeTTTlist</A>), <BR> --! pruned (TRUE if tree is already pruned for dead links)<BR> --! RETURNS: initial strategy and minimax tree for bl;<BR> --! if tree is not pruned, then prunes it<BR> set strategy to &#091;&#093;<BR> set minimaxtree to &#091;&#093;<BR> repeat with i=1 to bl.count<BR> strategy.add("unknown")<BR> minimaxtree.add("unknown")<BR> end repeat<BR> -- find all winning game states and remove any children of those nodes<BR> repeat with i=1 to bl.count<BR> if tree&#091;i&#093;&#091;1&#093;.count=0 then next repeat<BR> set b to bl&#091;i&#093;<BR> if <A HREF="Chapter 25.html#tttWin">tttWin</A>(b,1) then <BR> -- win for X<BR> set minimaxtree&#091;i&#093; to 1 <BR> set strategy&#091;i&#093; to "WinX"<BR> -- no possible children to a winning position<BR> if not pruned then <A HREF="Chapter 25.html#deletechildren">deletechildren</A>(tree,i,bl)<BR> <BR> else if <A HREF="Chapter 25.html#tttWin">tttWin</A>(b,2) then <BR> -- win for O<BR> set minimaxtree&#091;i&#093; to -1 <BR> set strategy&#091;i&#093; to "WinO"<BR> -- no possible children to a winning position<BR> if not pruned then <A HREF="Chapter 25.html#deletechildren">deletechildren</A>(tree,i,bl)<BR> <BR> else if not b.getone(0) then <BR> -- draw<BR> set minimaxtree&#091;i&#093; to 0 <BR> set strategy&#091;i&#093; to "draw"<BR> -- no need to prune: a full board has no children<BR> end if<BR> end repeat<BR> <BR> return &#091;strategy,minimaxtree&#093;<BR> <BR> <BR>end <BR><HR><A NAME="optimalGame"> </A>on optimalGame strategy, bl<BR> --! ARGUMENTS: strategy (completed), bl (output of <A HREF="Chapter 25.html#makeTTTlist">makeTTTlist</A>)<BR> --! RETURNS: a list of board positions from a strategically optimal game<BR> <BR> set r to &#091;bl&#091;1&#093;&#093;<BR> set i to 1<BR> repeat while true<BR> if stringp(strategy&#091;i&#093;) then return r<BR> r.add(bl&#091;strategy&#091;i&#093;&#093;)<BR> i=strategy&#091;i&#093;<BR> end repeat<BR>end<BR><HR><A NAME="minimaxIteration"> </A>on minimaxIteration strategy, minimaxtree, tree, bl<BR> --! ARGUMENTS: strategy, minimaxtree (lists in progress), tree (pruned), bl (output of <A HREF="Chapter 25.html#makeTTTlist">makeTTTlist</A>)<BR> --! RETURNS: the position of the last changed element, or the complete strategy if finished<BR> -- NB: call this function repeatedly to find the optimum strategy for the tree<BR> <BR> repeat with i=minimaxtree.count down to 1<BR> if tree&#091;i&#093;&#091;1&#093;.count=0 and i&#062;1 then next repeat -- impossible position<BR> if minimaxtree&#091;i&#093;="unknown" then -- not yet calculated<BR> -- work out whose move it is<BR> set c to 0<BR> repeat with j=1 to bl&#091;1&#093;.count<BR> if bl&#091;i&#093;&#091;j&#093;=0 then set c to c+1<BR> end repeat<BR> set ply to (c mod 2) <BR> -- ply is the move from position i: 1 for X, 0 for O<BR> set minimax to "unknown"<BR> set mv to 0<BR> repeat with j in tree&#091;i&#093;&#091;2&#093;<BR> set m to minimaxtree&#091;j&#093; <BR> if m="unknown" then return "failed at"&&i -- the algorithm has failed for some reason<BR> if m=1 and ply=1 then<BR> -- winning move for X: always play this move<BR> set minimax to 1<BR> set mv to j<BR> exit repeat<BR> else if m=-1 and ply=0 then<BR> -- winning move for O: always play this move<BR> set minimax to -1<BR> set mv to j<BR> exit repeat<BR> else <BR> -- find best non-winning move<BR> if minimax="unknown" then set minimax to m<BR> else if ply=1 then set minimax to max(m,minimax)<BR> else set minimax to min(m,minimax) <BR> if minimax=m then set mv to j<BR> end if<BR> end repeat<BR> <BR> set strategy&#091;i&#093; to mv<BR> set minimaxtree&#091;i&#093; to minimax<BR> if i=1 then return strategy -- all done<BR> return i<BR> end if<BR> end repeat<BR>end<BR><HR><A NAME="tttWin"> </A>on tttWin board, sym, returnlist<BR> --! ARGUMENTS: board (9-element list), sym (player to check), returnlist (boolean)<BR> --! RETURNS: 0 if the board is not a winning position for sym, <BR> --! 1 if sym wins and returnlist is false or void, otherwise a list of winning squares<BR> -- NB: the returnlist is used to calculate which set of squares won, in order to display<BR> -- the winning line<BR> set win to 0<BR> set c to 0<BR> repeat with i=1 to 9<BR> if board&#091;i&#093;=0 then set c to c+1<BR> end repeat<BR> if c mod 2 = sym mod 2 then return 0 -- wrong move<BR> -- check each possible winning line<BR> repeat with i=0 to 2<BR> if board&#091;i*3+1&#093;=sym and board&#091;i*3+2&#093;=sym and board&#091;i*3+3&#093;=sym then set win to &#091;i*3+1,i*3+2,i*3+3&#093;<BR> else if board&#091;i+1&#093;=sym and board&#091;i+4&#093;=sym and board&#091;i+7&#093;=sym then set win to &#091;i+1,i+4,i+7&#093;<BR> end repeat<BR> <BR> if board&#091;1&#093;=sym and board&#091;5&#093;=sym and board&#091;9&#093;=sym then win=&#091;1,5,9&#093;<BR> if board&#091;3&#093;=sym and board&#091;5&#093;=sym and board&#091;7&#093;=sym then win=&#091;3,5,7&#093;<BR> <BR> if listp(win) then -- win<BR> if not returnlist then return 1<BR> return win<BR> end if<BR> return 0 -- not a win<BR>end<BR><HR><A NAME="deletechildren"> </A>on deletechildren tree, i, bl<BR> --! ARGUMENTS: tree (output of <A HREF="Chapter 25.html#makeTTTtree">makeTTTtree</A>), i (node to clean up), bl (output of <A HREF="Chapter 25.html#makeTTTlist">makeTTTlist</A>)<BR> --! RETURNS: nothing, but removes (recursively) all children from node i<BR> --! and updates parent lists too.<BR> repeat with ch in tree&#091;i&#093;&#091;2&#093;<BR> tree&#091;ch&#093;&#091;1&#093;.deleteone(i)<BR> if tree&#091;ch&#093;&#091;1&#093;.count=0 then deletechildren(tree,ch,bl)<BR> end repeat<BR> tree&#091;i&#093;&#091;2&#093;=&#091;&#093;<BR>end<BR><HR></KBD><P><A HREF="math index.html">Back to index</A></PRE></BODY></HTML> 