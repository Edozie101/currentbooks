<HTML><HEAD><TITLE>chapter 10 (object modeling and collisions) functions</TITLE></HEAD><BODY><H2 ALIGN="center">Functions for cast member "chapter 10 (object modeling and collisions)" of castlib "math"</H2><P><PRE><KBD><A NAME="collisionMap"> </A>on collisionMap im, res, sensitivity<BR> --! ARGUMENTS: im (an image object), res (a positive integer), sensitivity (a float between 0 and 1)<BR> --! RETURNS: a new 1-bit image object with the collision map, scaled to 1/res of the size<BR> <BR> -- calculate height and width of collision map and create new image object<BR> set w to <A HREF="numerical utilities.html#ceil">ceil</A>(im.width)/float(res)<BR> set h to <A HREF="numerical utilities.html#ceil">ceil</A>(im.height)/float(res)<BR> set map to image(w,h,1)<BR> -- multiply sensitivity by 255 to get it into the correct range<BR> set sensitivity to sensitivity*255<BR> <BR> -- for each square of pixels in im<BR> repeat with x=0 to w-1<BR> set xstart to x*res<BR> repeat with y=0 to h-1<BR> set ystart to y*res<BR> set tot to 0<BR> -- set tot to the sum of all the colors in the square<BR> repeat with i=0 to res-1<BR> repeat with j=0 to res-1<BR> set c to im.getPixel(xstart+i, ystart+j, #rgb)<BR> if c=0 then next repeat<BR> set c.colorType to #rgb<BR> set tot to tot+255-(c.red+c.green+c.blue)/3.0<BR> end repeat<BR> end repeat<BR> -- and divide by the number of pixels in the square<BR> set tot to tot/(res*res)<BR> -- if tot is over the sensitivity threshold then create a black pixel in the cmap<BR> if tot&#062;sensitivity then<BR> set map.setpixel(x,y,1)<BR> end if<BR> end repeat<BR> end repeat<BR> return map<BR>end<BR><HR><A NAME="findEdges"> </A>on findEdges(bwImage)<BR> --! ARGUMENTS: bwImage (a 1-bit image)<BR> --! RETURNS: a 2-bit image where points inside have value 0, outside have 3, and edge have 1<BR> <BR> -- set newImage to a 2-bit copy of bwImage<BR> set newImage to image(bwImage.width,bwImage.height,2)<BR> newImage.copyPixels(bwImage,bwImage.rect,bwImage.rect)<BR> set neighborlist to &#091;point(0,1), point(1,0), point(0,-1),point(-1,0)&#093;<BR> -- for each point in bwImage<BR> repeat with i=0 to bwImage.width-1<BR> repeat with j=0 to bwImage.height-1<BR> set c to bwImage.getPixel(i,j).paletteindex<BR> if c=1 then -- if it's a black pixel<BR> repeat with neighbor in neighborlist<BR> set d to bwImage.getPixel(point(i,j)+neighbor).paletteindex<BR> if d=0 then<BR> -- the pixel has at least one white neighbor, so it's an edge<BR> newImage.setPixel(i,j,1)<BR> exit repeat<BR> end if<BR> end repeat<BR> <BR> end if <BR> end repeat<BR> end repeat<BR> <BR> return newImage<BR>end <BR><HR><A NAME="calculateNormals"> </A>on calculateNormals (<A HREF="chapter 10.html#collisionMap">collisionMap</A>)<BR> --! ARGUMENTS: <A HREF="chapter 10.html#collisionMap">collisionMap</A> (a 2-bit collision map with edges marked)<BR> --! RETURNS: a grayscale collision map image with normals encoded in shades of gray<BR> <BR> -- set newImage to an 8-bit copy of <A HREF="chapter 10.html#collisionMap">collisionMap</A><BR> set newImage to image(<A HREF="chapter 10.html#collisionMap">collisionMap</A>.width,<A HREF="chapter 10.html#collisionMap">collisionMap</A>.height,8,#grayscale)<BR> newImage.copyPixels(<A HREF="chapter 10.html#collisionMap">collisionMap</A>,<A HREF="chapter 10.html#collisionMap">collisionMap</A>.rect,<A HREF="chapter 10.html#collisionMap">collisionMap</A>.rect)<BR> set neighborlist to &#091;point(0,1), point(1,0), point(0,-1),point(-1,0)&#093;<BR> -- repeat for each point in <A HREF="chapter 10.html#collisionMap">collisionMap</A><BR> repeat with i=0 to <A HREF="chapter 10.html#collisionMap">collisionMap</A>.width-1<BR> repeat with j=0 to <A HREF="chapter 10.html#collisionMap">collisionMap</A>.height-1<BR> set c to <A HREF="chapter 10.html#collisionMap">collisionMap</A>.getPixel(i,j).paletteindex<BR> if c=0 or c=3 then next repeat<BR> -- point is an edge<BR> set clist to &#091;&#093;<BR> -- set clist to the list of neighbors of the point<BR> repeat with k=1 to 4<BR> set neighbor to neighborlist&#091;k&#093;<BR> set d to <A HREF="chapter 10.html#collisionMap">collisionMap</A>.getPixel(point(i,j)+neighbor).paletteindex<BR> if d&#062;0 then <BR> clist.add(k)<BR> end if<BR> end repeat<BR> set neigh to clist.count -- number of solid neighbors<BR> case neigh of<BR> 0: -- lone pixel<BR> newImage.setpixel(i,j,255)<BR> next repeat<BR> 1: -- end of a 'spike': normal is along the line of the spike<BR> set v to -neighborlist&#091;clist&#091;1&#093;&#093;<BR> 2: -- either a point on a line, or a corner<BR> if clist.getone(1) and clist.getone(3) then <BR> set v to point(1,0) -- horizontal line<BR> else if clist.getone(2) and clist.getone(4) then <BR> set v to point(0,1) -- vertical line<BR> else <BR> -- corner: set to a 45 degree angle half-way between the two sides<BR> set v to -(neighborlist&#091;clist&#091;1&#093;&#093;+neighborlist&#091;clist&#091;2&#093;&#093;)/2.0<BR> end if<BR> 3: -- a straight edge with a solid back: normal towards the non-solid neighbor<BR> repeat with k=1 to 4<BR> if not clist.getone(k) then set v to neighborlist&#091;k&#093;<BR> end repeat<BR> end case<BR> set v to <A HREF="2D vectors.html#norm">norm</A>(v)<BR> newImage.setpixel(i,j,<A HREF="chapter 10.html#writeColor">writeColor</A>(v))<BR> end repeat<BR> end repeat<BR> <BR> return newImage<BR>end <BR><HR><A NAME="refineNormals"> </A>on refineNormals (<A HREF="chapter 10.html#collisionMap">collisionMap</A>)<BR> --! ARGUMENTS: <A HREF="chapter 10.html#collisionMap">collisionMap</A> (an 8-bit collision map with normals calculated)<BR> --! RETURNS: a new collision map image with averaged normals encoded in shades of gray<BR> <BR> -- set newImage to a copy of <A HREF="chapter 10.html#collisionMap">collisionMap</A><BR> set newImage to <A HREF="chapter 10.html#collisionmap">collisionmap</A>.duplicate()<BR> -- repeat for each point in <A HREF="chapter 10.html#collisionMap">collisionMap</A><BR> repeat with i=0 to <A HREF="chapter 10.html#collisionMap">collisionMap</A>.width-1<BR> repeat with j=0 to <A HREF="chapter 10.html#collisionMap">collisionMap</A>.height-1<BR> set c to <A HREF="chapter 10.html#collisionMap">collisionMap</A>.getPixel(i,j).paletteindex<BR> if c=0 or c=255 then next repeat<BR> -- point is an edge<BR> -- find sum of normals in near vicinity<BR> set n to point(0,0)<BR> set ct to 0<BR> repeat with k=-1 to 1<BR> repeat with l=-1 to 1<BR> set c to <A HREF="chapter 10.html#collisionMap">collisionMap</A>.getPixel(i+k,j+l).paletteindex<BR> if c=0 or c=255 then next repeat<BR> set n to n+<A HREF="chapter 10.html#readColor">readColor</A>(c)<BR> set ct to ct+1<BR> end repeat<BR> end repeat<BR> set n to n/ct -- average of nearby normals (including this one)<BR> <BR> newImage.setpixel(i,j,<A HREF="chapter 10.html#writeColor">writeColor</A>(n))<BR> end repeat<BR> end repeat<BR> <BR> return newImage<BR>end <BR><HR><A NAME="writeColor"> </A>on writeColor(v)<BR> --! ARGUMENTS: v (a 2d vector)<BR> --! RETURNS: the angle of v encoded as a number from 1 to 254<BR> set a to <A HREF="2D vectors.html#constrainAngle">constrainAngle</A>(<A HREF="2D vectors.html#angleOf">angleOf</A>(v),0)<BR> return integer(a*253/(2*pi))+1<BR>end <BR><HR><A NAME="readColor"> </A>on readColor(c)<BR> --! ARGUMENTS: c (a value between 1 and 254)<BR> --! RETURNS: a vector whose angle is encoded by c<BR> set a to (c-1)*2*pi/253<BR> return <A HREF="2D vectors.html#directionVector">directionVector</A>(a)<BR>end <BR><HR><A NAME="pointInsidePolygon"> </A>on pointInsidePolygon pt, poly, outpoint<BR> --! ARGUMENTS: pt (a 2d vector), poly (a list of 2D vectors), <BR> --! outpoint (optional point known to be outside the polygon)<BR> --! RETURNS: TRUE if pt is inside the polygon, FALSE otherwise<BR> if voidp(outpoint) then<BR> -- choose an arbitrary point outside the polygon<BR> -- set mx to the maximum x-value in poly<BR> set mx to poly&#091;1&#093;&#091;1&#093;<BR> repeat with i=2 to poly.count<BR> if poly&#091;i&#093;&#091;1&#093;&#062;mx then set mx to poly&#091;i&#093;&#091;1&#093;<BR> end repeat<BR> set outpoint to point(mx+10,0)<BR> end if<BR> -- now count the intersections along the ray from pt to outpoint<BR> set intersections to 0<BR> set c to poly.count<BR> repeat with i=1 to c<BR> set p1 to poly&#091;i&#093;<BR> set p2 to poly&#091;(i mod c)+1&#093;<BR> set t to <A HREF="2d vector algebra.html#intersection">intersection</A>(p1,p2,pt,outPoint)<BR> if t=#none then next repeat<BR> if t=0 or t=1 then <BR> -- try a different ray<BR> return pointInsidePolygon(pt, poly, outpoint+point(0,100))<BR> end if<BR> set intersections to intersections+1<BR> end repeat<BR> if (intersections mod 2)=1 then return true<BR> return false<BR>end <BR><HR><A NAME="pointCmapIntersection"> </A>on pointCmapIntersection(p, s, q, c)<BR> --! ARGUMENTS: p,s,q (2d vectors), c (8-bit collision map image)<BR> --! RETURNS: time of collision or #none, for a particle at p moving to p+s <BR> --! and a collision-mapped object at q.<BR> -- NB: this is only a rough example: a better algorithm would use<BR> -- Bresenham for integer calculations, and/or a bracketing method to <BR> -- home in on the edge.<BR> set d to <A HREF="2D vectors.html#mag">mag</A>(s)<BR> if d=0 then return #none<BR> set sn to s/d<BR> set st to p-q<BR> repeat with i=1 to integer(d)<BR> set pos to st+i*sn<BR> set col to c.getPixel(pos).paletteindex<BR> if col&#062;0 then return d/i<BR> end repeat<BR> return #none<BR>end <BR><HR></KBD><P><A HREF="math index.html">Back to index</A></PRE></BODY></HTML> 