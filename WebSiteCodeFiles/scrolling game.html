<HTML><HEAD><TITLE>scrolling game functions</TITLE></HEAD><BODY><H2 ALIGN="center">Functions for cast member "scrolling game" of castlib "tileScroller"</H2><P><PRE><KBD><A NAME="detectCollisionWithWorld"> </A>on detectCollisionWithWorld me, c, w, h, displacement, ignore<BR> -- w and h are the width and height of the colliding box<BR> -- c is its top-left corner<BR> <BR> -- determine the colliding edges<BR> if ignore=#left or ignore=#right then set edge1 to #none<BR> else if displacement&#091;1&#093;=0 then set edge1 to #none<BR> else if displacement&#091;1&#093;&#062;0 then set edge1 to c&#091;1&#093;+w<BR> else set edge1 to c&#091;1&#093;<BR> <BR> if ignore=#top or ignore=#bottom then set edge2 to #none<BR> else if displacement&#091;2&#093;=0 then set edge2 to #none<BR> else if displacement&#091;2&#093;&#062;0 then set edge2 to c&#091;2&#093;+h<BR> else set edge2 to c&#091;2&#093;<BR> <BR> -- calculate first collision<BR> set t1 to 2<BR> -- horizontally<BR> if edge1&#060;&#062;#none then <BR> set currTileX to ceil(edge1/16.0) <BR> <BR> set newTileX to ceil((edge1+displacement&#091;1&#093;)/16.0)<BR> if currTileX&#062;newTileX then -- moving into a new cell to left<BR> set t1 to ((currTileX-1)*16.0-edge1)/displacement&#091;1&#093;<BR> else if currTileX&#060;newTileX then -- moving into a new cell to right<BR> set t1 to (currTileX*16.0-edge1)/displacement&#091;1&#093;<BR> end if<BR> end if<BR> <BR> set t2 to 2<BR> if edge2&#060;&#062;#none then<BR> set currTileY to ceil(edge2/16.0)<BR> if currTileY=edge2/16.0&#060;0.01 and displacement&#091;2&#093;&#060;0 then currTileY=currTileY+1<BR> set newTileY to ceil((edge2+displacement&#091;2&#093;)/16.0)<BR> if currTileY&#062;newTileY then -- moving into a new cell to top<BR> set t2 to ((currTileY-1)*16.0-edge2)/displacement&#091;2&#093;<BR> else if currTileY&#060;newTileY then -- moving into a new cell to bottom<BR> set t2 to (currTileY*16.0-edge2)/displacement&#091;2&#093;<BR> end if<BR> end if<BR> <BR> if min(t1,t2)=2 then return #none -- no change of tile<BR> if t2=t1 then -- simultaneous collision on both sides<BR> set displacement&#091;2&#093; to displacement&#091;2&#093;*0.99 -- reduce vertical displacement slightly<BR> return me.detectcollisionwithworld(c, w, h, displacement) -- re-calculate<BR> end if<BR> <BR> if t2&#060;t1 then -- vertical collision first<BR> set newTile to newTileY<BR> set currTile to currTileY<BR> set checktile to &#091;ceil(c&#091;1&#093;/16.0),ceil((c&#091;1&#093;+w)/16.0)&#093;<BR> set mx to ptiles.count<BR> if displacement&#091;2&#093;&#062;0 then dir=#bottom<BR> else dir=#top<BR> else -- horizontal collision first<BR> set newTile to newTileX<BR> set currTile to currTileX<BR> set checktile to &#091;ceil(c&#091;2&#093;/16.0),ceil((c&#091;2&#093;+h)/16.0)&#093;<BR> set mx to ptiles&#091;1&#093;.count<BR> if displacement&#091;1&#093;&#062;0 then dir=#right<BR> else dir=#left<BR> end if<BR> -- checktile is the range of tiles along the leading edge.<BR> if checktile&#091;1&#093;=0 then checktile&#091;1&#093;=1 -- ensure it doesn't go over the edge<BR> set t to min(t1, t2)<BR> <BR> <BR> if newTile&#060;1 or newTile&#062;mx then<BR> -- edge of map<BR> return &#091;c+t*displacement,point(0,0),dir&#093;<BR> end if<BR> d=displacement<BR> -- check whether any tile entered is impermeable<BR> repeat with i=checktile&#091;1&#093; to checktile&#091;2&#093;<BR> if dir=#bottom or dir=#top then <BR> tile=ptiles&#091;newTile&#093;&#091;i&#093;<BR> else <BR> tile=ptiles&#091;i&#093;&#091;newTile&#093;<BR> end if<BR> if tile&#062;0 then <BR> -- potential collision<BR> tile=ptiledata&#091;tile&#093;<BR> if tile.solidity=#solid or (tile.solidity=#top and dir=#bottom) then<BR> -- tile collision<BR> -- move to collision point<BR> return &#091;c+t*displacement,point(0,0),dir&#093;<BR> end if<BR> end if<BR> end repeat<BR> -- no collision: recurse<BR> return me.detectCollisionWithWorld(c+t*displacement, w, h, (1-t)*d, dir)<BR> <BR>end <BR><HR><A NAME="detectHorizontalattachment"> </A>on detectHorizontalAttachment me, c, w, h, att<BR> -- w and h are the width and height of the box<BR> -- c is the top-left corner<BR> <BR> -- determine the colliding edges<BR> if att=1 then set edge to c&#091;1&#093;+w<BR> else set edge to c&#091;1&#093;<BR> <BR> -- check relative position to cell<BR> set curr to ceil(edge/16.0) <BR> if curr=edge/16.0 and att=-1 then set curr to curr+1<BR> set offs to ceil((edge +att)/16.0)<BR> if curr=offs then return 0<BR> if offs=0 or offs&#062;ptiles&#091;1&#093;.count then return 1<BR> set checktile to &#091;ceil(c&#091;2&#093;/16.0),ceil((c&#091;2&#093;+h)/16.0)&#093;<BR> if checktile&#091;1&#093;=0 then checktile&#091;1&#093;=1<BR> if checktile&#091;2&#093;&#062;ptiles.count then checktile&#091;2&#093;=ptiles.count<BR> repeat with i=checktile&#091;1&#093; to checktile&#091;2&#093;<BR> tile=ptiles&#091;i&#093;&#091;offs&#093;<BR> <BR> if tile&#062;0 then <BR> -- potential collision<BR> tile=ptiledata&#091;tile&#093;<BR> if tile.solidity=#solid then <BR> return 1<BR> end if<BR> end if<BR> end repeat<BR> <BR> return 0<BR>end<BR><HR><A NAME="detectVerticalattachment"> </A>on detectVerticalAttachment me, c, w, h, att<BR> -- w and h are the width and height of the box<BR> -- c is the top-left corner<BR> <BR> -- determine the colliding edges<BR> if att=1 then set edge to c&#091;2&#093;<BR> else set edge to c&#091;2&#093;+h<BR> <BR> -- check relative position to cell<BR> set curr to ceil(edge/16.0) <BR> if curr=edge/16.0 and att=1 then set curr to curr+1<BR> set offs to ceil((edge -att)/16.0)<BR> if curr=offs then return 0<BR> if offs=0 or offs&#062;ptiles.count then return 1<BR> set checktile to &#091;ceil(c&#091;1&#093;/16.0),ceil((c&#091;1&#093;+w)/16.0)&#093;<BR> if checktile&#091;1&#093;=0 then checktile&#091;1&#093;=1<BR> if checktile&#091;2&#093;&#062;ptiles&#091;1&#093;.count then checktile&#091;2&#093;=ptiles&#091;1&#093;.count<BR> repeat with i=checktile&#091;1&#093; to checktile&#091;2&#093;<BR> tile=ptiles&#091;offs&#093;&#091;i&#093;<BR> <BR> if tile&#062;0 then <BR> -- potential collision<BR> tile=ptiledata&#091;tile&#093;<BR> if tile.solidity=#solid or (tile.solidity=#top and att=-1) then return 1<BR> <BR> end if<BR> end repeat<BR> <BR> return 0<BR>end<BR><HR><A NAME="beginSprite"> </A>on beginsprite me<BR> -- initialise world<BR> psprite=sprite(me.spritenum)<BR> pmember=new(#bitmap)<BR> pw=psprite.width<BR> ph=psprite.height<BR> pviewport=image(pw,ph,16)<BR> pcomposite=image(pw,ph,16)<BR> ptl=psprite.loc<BR> psprite.member=pmember<BR> psprite.loc=ptl+point(pw/2,ph/2)<BR> me.<A HREF="scrolling game.html#initlevel">initlevel</A>(1) <BR>end<BR><HR><A NAME="endSprite"> </A>on endsprite me<BR> erase pmember<BR>end<BR><HR><A NAME="initlevel"> </A>on initlevel me, n<BR> -- read data from cast member<BR> ptiles=value(member("level"&&n&&"tiles").text)<BR> plevel=n<BR> ptiledata=&#091;&#093;<BR> phtiles=ptiles&#091;1&#093;.count<BR> pvtiles=ptiles.count<BR> plevelw=phtiles*16<BR> plevelh=pvtiles*16<BR> -- load in appropriate tiles for level<BR> inlevel=&#091;&#093;<BR> repeat with i=1 to pvtiles<BR> repeat with j=1 to phtiles<BR> t=ptiles&#091;i&#093;&#091;j&#093;<BR> if t=0 then next repeat<BR> if inlevel.getone(t) then<BR> ptiles&#091;i&#093;&#091;j&#093;=inlevel.getpos(t)<BR> else<BR> inlevel.add(t)<BR> ptiledata.add(value(member(t,"tile data").text))<BR> ptiles&#091;i&#093;&#091;j&#093;=inlevel.count<BR> end if<BR> end repeat<BR> end repeat<BR> <BR> -- for each tile, find its image - note that we could create animated<BR> -- or melting tiles here<BR> repeat with t in ptiledata<BR> t&#091;#image&#093;=member(t&#091;#member&#093;).image<BR> if not voidp(t&#091;#othertiles&#093;) then<BR> repeat with i=1 to t.othertiles.count<BR> m=t.othertiles&#091;i&#093;<BR> if inlevel.getone(m) then<BR> t.othertiles&#091;i&#093;=inlevel.getpos(m)<BR> else<BR> inlevel.add(m)<BR> ptiledata.add(value(member(t.next,"tile data").text))<BR> t.othertiles&#091;i&#093;=inlevel.count<BR> end if<BR> end repeat<BR> end if<BR> end repeat<BR> panimtiles=&#091;&#093;<BR> repeat with i=1 to pvtiles<BR> repeat with j=1 to phtiles<BR> t=ptiles&#091;i&#093;&#091;j&#093;<BR> if t=0 then next repeat<BR> if ptiledata&#091;t&#093;.animated then<BR> panimtiles.add(&#091;#row:i,#col:j,#mode:ptiledata&#091;t&#093;.initialmode&#093;)<BR> end if<BR> end repeat<BR> end repeat<BR> <BR> -- draw level into a large image object - we'll copy parts of this<BR> -- image to make our viewport<BR> <BR> r=rect(0,0,16,16)<BR> pimage=image(plevelw,plevelh,16)<BR> repeat with i=1 to pvtiles<BR> repeat with j=1 to phtiles<BR> t=ptiles&#091;i&#093;&#091;j&#093;<BR> if t=0 then next repeat<BR> pimage.copypixels(ptiledata&#091;t&#093;.image,r+rect(j-1,i-1,j-1,i-1)*16,r)<BR> <BR> end repeat<BR> end repeat<BR> <BR> -- read in character data<BR> c=value(member("level"&&n&&"characters").text)<BR> pcharacters=&#091;&#093;<BR> repeat with l in c<BR> -- create a script object to deal with each character<BR> pcharacters.add(script("character").new(l))<BR> end repeat<BR> <BR> pplayer=pcharacters&#091;1&#093;<BR> -- create a camera object<BR> pcamera=script("camera").new(pplayer.pos(),pw,ph,plevelw, plevelh)<BR>end<BR><HR><A NAME="enterFrame"> </A>on enterframe me<BR> -- set movement targets<BR> repeat with c in pcharacters<BR> c.attemptmove()<BR> end repeat<BR> -- collision detection / resolution<BR> -- for each character with tiles and other objects<BR> repeat with i=1 to pcharacters.count<BR> c=pcharacters&#091;i&#093;<BR> if c.moving() then<BR> if c.collideswithworld() then<BR> coll=me.<A HREF="scrolling game.html#detectCollisionWithWorld">detectCollisionWithWorld</A>(c.pos(),c.width(),c.height(),c.vect())<BR> if coll&#060;&#062;#none then c.bounce(coll)<BR> end if<BR> end if<BR> end repeat<BR> <BR> -- perform movements<BR> repeat with c in pcharacters<BR> c.update()<BR> end repeat<BR> <BR> -- check for attachments with walls or floors<BR> repeat with i=1 to pcharacters.count<BR> c=pcharacters&#091;i&#093;<BR> if c.moved() then<BR> if c.collideswithworld() then<BR> if c.attachedv() then<BR> if not me.<A HREF="scrolling game.html#detectVerticalattachment">detectVerticalattachment</A>(c.pos(),c.width(),c.height(), c.attachedv()) then c.detachV()<BR> end if<BR> if c.attachedH() then<BR> if not me.<A HREF="scrolling game.html#detectHorizontalattachment">detectHorizontalattachment</A>(c.pos(),c.width(),c.height(), c.attachedh()) then c.detachH()<BR> end if<BR> end if<BR> end if<BR> end repeat<BR> <BR> -- set new camera position<BR> cam=pplayer.newcamerapos()<BR> if cam&#060;&#062;0 then pcamera.settarget(cam)<BR> -- draw screen<BR> if pcamera.update() then<BR> r=pcamera.getviewport()<BR> pviewport.copypixels(pimage,pviewport.rect,r)<BR> end if<BR> pcomposite=pviewport.duplicate()<BR> -- add visible characters to viewport<BR> repeat with c in pcharacters<BR> r= pcamera.getrect(c.getrect()) <BR> if r&#060;&#062;0 then <BR> i=c.getimage()<BR> pcomposite.copypixels(i,r,i.rect,&#091;#ink:#backgroundtransparent&#093;)<BR> end if<BR> end repeat<BR> <BR> pmember.image=pcomposite<BR>end<BR><HR></KBD><P><A HREF="tileScroller index.html">Back to index</A></PRE></BODY></HTML> 