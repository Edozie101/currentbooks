<HTML><HEAD><TITLE>chapter 9 (collision resolution) functions</TITLE></HEAD><BODY><H2 ALIGN="center">Functions for cast member "chapter 9 (collision resolution)" of castlib "math"</H2><P><PRE><KBD><A NAME="resolveCollisionFree"> </A>on resolveCollisionFree (ob1, ob2, n)<BR> --! ARGUMENTS: ob1, ob2 (colliding objects), n (2D vector)<BR> --! RETURNS: none, but sets velocities of ob1 and ob2 after elastic collision along n<BR> set r to ob1.getMass()/float(ob2.getMass())<BR> set <A HREF="Floats.html#base">base</A> to ob2.getVelocity()<BR> set u to ob1.getVelocity()-<A HREF="Floats.html#base">base</A><BR> set un to <A HREF="2D vectors.html#componentVector">componentVector</A>(u,n)<BR> set ut to u-un<BR> set vn to un*(r-1)/(r+1)<BR> set wn to un*2*r/(r+1)<BR> ob1.setVelocity(ut+vn+<A HREF="Floats.html#base">base</A>)<BR> ob2.setVelocity(wn+<A HREF="Floats.html#base">base</A>)<BR>end <BR><HR><A NAME="resolvecollisionfixed"> </A>on resolveCollisionFixed (ob, n)<BR> --! ARGUMENTS: ob (colliding object), n (2D vector)<BR> --! RETURNS: none, but sets velocity of ob after elastic collision along n<BR> set u to ob.getVelocity()<BR> set un to <A HREF="2D vectors.html#componentVector">componentVector</A>(u,n)<BR> ob.setVelocity( u-2*un)<BR>end<BR><HR><A NAME="resolveCollisionEqualMass"> </A>on resolveCollisionEqualMass (ob1, ob2, n)<BR> --! ARGUMENTS: ob1, ob2 (colliding objects), n (2D vector)<BR> --! RETURNS: none, but sets velocities of ob1 and ob2 after collision along n<BR> set u1 to ob1.getVelocity()<BR> set u2 to ob2.getVelocity()<BR> set u to u1-u2<BR> set un to <A HREF="2D vectors.html#componentVector">componentVector</A>(u,n)<BR> set ut to u-un<BR> ob1.setVelocity(ut+u2)<BR> ob2.setVelocity(un+u2)<BR>end <BR><HR><A NAME="resolveInelasticCollisionFree"> </A>on resolveInelasticCollisionFree (ob1, ob2, e, n)<BR> --! ARGUMENTS: ob1, ob2 (colliding objects), e (number between 0 and 1), n (2D vector)<BR> --! RETURNS: none, but sets velocities of ob1 and ob2 after inelastic collision along n<BR> set r to ob1.getMass()/ob2.getMass()<BR> set <A HREF="Floats.html#base">base</A> to ob2.getVelocity()<BR> set u to ob1.getVelocity()-<A HREF="Floats.html#base">base</A><BR> set sq to sqrt(e-(e-1)*r)<BR> set un to <A HREF="2D vectors.html#componentVector">componentVector</A>(u,n)<BR> set ut to u-un<BR> set vn to un*(r-sq)/(r+1)<BR> set wn to un*r*(1+sq)/(r+1)<BR> ob1.setVelocity(ut+vn+<A HREF="Floats.html#base">base</A>)<BR> ob2.setVelocity(wn+<A HREF="Floats.html#base">base</A>)<BR>end <BR><HR><A NAME="resolveInelasticCollisionFixed"> </A>on resolveInelasticCollisionFixed (ob, e, n)<BR> --! ARGUMENTS: ob (colliding object), e (number between 0 and 1), n (2D vector)<BR> --! RETURNS: none, but sets velocity of ob after inelastic collision along n<BR> set sq to sqrt(e)<BR> set u to ob.getVelocity()<BR> set un to <A HREF="2D vectors.html#componentVector">componentVector</A>(u,n)<BR> set ut to u-un<BR> set vn to -un*sq<BR> ob.setVelocity(ut+vn)<BR>end <BR><HR><A NAME="resolveAngularCollision"> </A>on resolveAngularCollision ob1, ob2, n, mom1, mom2<BR> --! ARGUMENTS: ob1, ob2 (colliding objects), n, mom1, mom2 (2D vectors)<BR> --! RETURNS: none, but sets velocities and ang. velocities of ob1 and ob2 <BR> --! after collision along n at a point mom1 from the center of ob1 and mom2 from ob2<BR> <BR> set u1 to ob1.getVelocity()<BR> set u2 to ob2.getVelocity()<BR> set om1 to ob1.getAngularVelocity()<BR> set om2 to ob2.getAngularVelocity()<BR> -- calculate numerator of impulse<BR> set J to 2*<A HREF="2D vectors.html#dotProd">dotProd</A>(u2-u1+mom2*om2-mom1*om1,n)<BR> set denom to 0<BR> -- calculate denominator of impulse depending on which objects are free to move<BR> if not ob1.fixedLinear() then <BR> set m1 to ob1.getMass()<BR> set denom to denom + (1.0/m1)<BR> end if<BR> if not ob2.fixedLinear() then <BR> set m2 to ob2.getMass()<BR> set denom to denom + (1.0/m2)<BR> end if<BR> if not ob1.fixedAngular() then <BR> set moi1 to ob1.getMOI()<BR> set dp1 to <A HREF="2D vectors.html#dotProd">dotProd</A>(mom1,n)<BR> set denom to denom + (dp1*dp1/moi1) <BR> end if<BR> if not ob2.fixedAngular() then <BR> set moi2 to ob2.getMOI()<BR> set dp2 to <A HREF="2D vectors.html#dotProd">dotProd</A>(mom2,n)<BR> set denom to denom + (dp2*dp2/moi2)<BR> end if<BR> if denom=0 then exit -- coincident axes or other weirdness<BR> -- calculate impulse<BR> set J to J/denom<BR> -- set resultant velocities<BR> if not ob1.fixedLinear() then ob1.setVelocity(u1+J*n/m1) <BR> if not ob2.fixedLinear() then ob2.setVelocity(u2-J*n/m2) <BR> if not ob1.fixedAngular() then ob1.setAngularVelocity(om1+J*dp1/moi1) <BR> if not ob2.fixedAngular() then ob2.setAngularVelocity(om2-J*dp2/moi2)<BR>end <BR><HR><A NAME="resolveAngularBounce"> </A>on resolveAngularBounce (ob)<BR> --! ARGUMENTS: ob (colliding object)<BR> --! RETURNS: none, but rebounds object from a fixed wall<BR> ob.reverseAngularVelocity()<BR>end<BR><HR></KBD><P><A HREF="math index.html">Back to index</A></PRE></BODY></HTML> 