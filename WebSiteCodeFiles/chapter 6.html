<HTML><HEAD><TITLE>chapter 6 (calculus) functions</TITLE></HEAD><BODY><H2 ALIGN="center">Functions for cast member "chapter 6 (calculus)" of castlib "math"</H2><P><PRE><KBD><A NAME="newtonRaphson"> </A>on newtonRaphson(func, deriv, x1, resolution, maxcount, c)<BR> --! ARGUMENTS: func, deriv (functions to be evaluated using the <A HREF="algebra.html#calculateValue">calculateValue</A> method),<BR> --! x1 (starting value), resolution (how close we want to be to a root)<BR> --! OPTIONAL ARGUMENTS: maxcount (maximum number of iterations - default is 20),<BR> --! c (current number of iterations)<BR> --! RETURNS: The value of x at the root or #nonefound<BR> <BR> -- check if the number of iterations is too high<BR> if voidp(maxcount) then set maxcount to 20<BR> if maxcount&#062;0 then<BR> set c to c+1<BR> if c&#062;maxcount then return #nonefound<BR> end if<BR> -- check if solved<BR> set f1 to <A HREF="algebra.html#calculateValue">calculateValue</A>(func, x1)<BR> if abs(f1)&#060;resolution then return x1<BR> -- find the derivative at x1<BR> set g1 to <A HREF="algebra.html#calculateValue">calculateValue</A>(deriv, x1)<BR> -- if the derivative is zero then move a small distance away and try again<BR> if g1=0 then return newtonRaphson(func, deriv, x1+resolution, resolution)<BR> -- calculate the new value of x and iterate<BR> set x2 to x1-f1/g1<BR> return newtonRaphson(func, deriv, x2, resolution, maxcount, c)<BR>end <BR><HR><A NAME="bisectionMethod"> </A>on bisectionMethod(func, x1, x2, resolution, yresolution, pos, f1, f2)<BR> --! ARGUMENTS: func (a function to be evaluated using <A HREF="algebra.html#calculateValue">calculateValue</A>), x1, x2 (current x-brackets)<BR> --! resolution (minimum distance between interesting x-values), yresolution (minimum distance from a root)<BR> --! OPTIONAL ARGUMENTS: f1, f2 (values of the function at x1 and x2), pos (TRUE to never return a value of x with negative function values)<BR> --! RETURNS: a value of x where func(x) is 0 or near to it. If pos is TRUE then func(x)&#062;=0<BR> --! if func(x1) and func(x2) are the same sign then returns #nonefound<BR> <BR> -- calculate f1 and f2 if not specified<BR> if voidp(f1) then <BR> set f1 to <A HREF="algebra.html#calculateValue">calculateValue</A>(func, x1, 1)<BR> if abs(f1)&#060;yresolution then return x1<BR> end if<BR> <BR> if voidp(f2) then <BR> set f2 to <A HREF="algebra.html#calculateValue">calculateValue</A>(func, x2, 1)<BR> if abs(f2)&#060;yresolution then return x2<BR> end if<BR> if f1*f2&#062;0 then return #nonefound<BR> <BR> <BR> -- if we are already very near to the solution then return the best value so far<BR> if abs(x1-x2)&#060;=resolution then <BR> if pos then<BR> if f1&#062;=0 then return x1 <BR> return x2<BR> else<BR> return x1<BR> end if<BR> <BR> end if<BR> <BR> -- calculate f3 at the midpoint<BR> set x3 to (x1+x2)/2.0<BR> set f3 to <A HREF="algebra.html#calculateValue">calculateValue</A>(func, x3, 1)<BR> <BR> -- check if near to a root<BR> if abs(f3)&#060;=yresolution then return x3<BR> <BR> -- if not, iterate with the appropriate brackets<BR> if f1*f3&#060;0 then return bisectionMethod(func, x1, x3, resolution, yresolution, pos, f1, f3)<BR> return bisectionMethod(func, x3, x2, resolution, yresolution, pos, f3, f2)<BR>end <BR><HR><A NAME="secantMethod"> </A>on secantMethod(func, x1, x2, resolution, yresolution, maxcount, pos, c, f1, f2)<BR> --! ARGUMENTS: func (a function to be evaluated using <A HREF="algebra.html#calculateValue">calculateValue</A>), x1, x2 (current x-brackets)<BR> --! resolution (minimum distance between interesting x-values), yresolution (minimum distance from a root)<BR> --! OPTIONAL ARGUMENTS: f1, f2 (values of the function at x1 and x2), pos (TRUE to never return a value of x with negative function values)<BR> --! maxcount (maximum number of iterations - default is 20), c (current number of iterations)<BR> --! RETURNS: a value of x where func(x) is 0 or near to it. If pos is TRUE then func(x)&#062;=0<BR> --! if maximum number of iterations exceeded then returns #nonefound<BR> <BR> <BR> -- check if the number of iterations is too high<BR> if voidp(maxcount) then set maxcount to 20<BR> if maxcount&#062;0 then<BR> set c to c+1<BR> if c&#062;maxcount then return #nonefound<BR> end if<BR> <BR> -- calculate f1 and f2 if not specified<BR> if voidp(f1) then <BR> set f1 to <A HREF="algebra.html#calculateValue">calculateValue</A>(func, x1)<BR> if abs(f1)&#060;yresolution then return x1<BR> end if<BR> <BR> if voidp(f2) then <BR> set f2 to <A HREF="algebra.html#calculateValue">calculateValue</A>(func, x2)<BR> if abs(f2)&#060;yresolution then return x2<BR> end if<BR> <BR> -- if f1=f2 then move to a slightly different pair of values<BR> if f1=f2 then<BR> return secantMethod(func, x1, x2+resolution, resolution, yresolution, maxcount, pos, c, f1)<BR> end if<BR> <BR> -- if we are already very near to the solution then return the best value so far<BR> if abs(x1-x2)&#060;=resolution and f1*f2&#060;0 then <BR> if pos then<BR> if f1&#062;=0 then return x1 <BR> return x2<BR> else<BR> return x1<BR> end if<BR> <BR> end if<BR> <BR> -- calculate f3 at the extrapolated end-point<BR> set x3 to (x1*f2-x2*f1)/(f2-f1)<BR> set f3 to <A HREF="algebra.html#calculateValue">calculateValue</A>(func, x3)<BR> <BR> -- check if near to a root<BR> if abs(f3)&#060;=yresolution then return x3<BR> <BR> -- if not, iterate with the new brackets<BR> if abs(f1)&#060;abs(f2) then return secantMethod(func, x1, x3, resolution, yresolution, maxcount, pos, c, f1, f3)<BR> return secantMethod(func, x2, x3, resolution, yresolution, maxcount, pos, c, f2, f3)<BR>end <BR><HR><A NAME="drawDifferentialEquation"> </A>on drawDifferentialEquation (functionToDraw, params)<BR> --! ARGUMENTS: functionToDraw (a function of x and/or y, as a string, giving the gradient at the point (x, y))<BR> --! params (a property list with any or all of the following properties:<BR> --! #minX, #maxX: Minimum and maximum x-values to be plotted (default:from 0 to 100)<BR> --! #minY, #maxY: Minimum and maximum y-values to be plotted (default:from 0 to 100)<BR> --! #res: Number of x/y-points to be plotted (evenly spaced; an odd number is best) (default:21)<BR> --! #w, #h: The width and height of the end image in pixels (default: 200))<BR> --! RETURNS: a new cast member with an image of the graph<BR> <BR> bord=20<BR> <BR> -- set defaults<BR> if not listp(params) then params=&#091;:&#093;<BR> else if ilk(params)&#060;&#062;#proplist then params=&#091;:&#093;<BR> <BR> if voidp(params&#091;#minx&#093;) then <BR> if voidp(params&#091;#maxx&#093;) then minx=0.0<BR> else minx=min(params.maxx-100.0,0)<BR> else if not integerp(params.minx) and not floatp(params.minx) then <BR> if voidp(params&#091;#maxx&#093;) then minx=0.0<BR> else minx=min(params.maxx-100.0,0)<BR> else<BR> minx=float(params.minx)<BR> end if<BR> if voidp(params&#091;#maxx&#093;) then maxx=minx+100<BR> else if not integerp(params.maxx) and not floatp(params.maxx) then maxx=minx+100<BR> else if params.maxx&#060;minx then <BR> maxx=minx<BR> minx=float(params.maxx)<BR> else if params.maxx=minx then <BR> maxx=minx+100<BR> else maxx=float(params.maxx)<BR> if voidp(params&#091;#miny&#093;) then <BR> if voidp(params&#091;#maxy&#093;) then miny=0.0<BR> else miny=min(params.maxy-100.0,0)<BR> else if not integerp(params.miny) and not floatp(params.miny) then <BR> if voidp(params&#091;#maxy&#093;) then miny=0.0<BR> else miny=min(params.maxy-100.0,0)<BR> else<BR> miny=float(params.miny)<BR> end if<BR> if voidp(params&#091;#maxy&#093;) then maxy=miny+100<BR> else if not integerp(params.maxy) and not floatp(params.maxy) then maxy=miny+100<BR> else if params.maxy&#060;miny then <BR> maxy=miny<BR> miny=float(params.maxy)<BR> else if params.maxy=miny then <BR> maxy=miny+100<BR> else maxy=float(params.maxy)<BR> <BR> <BR> if voidp(params&#091;#res&#093;) then res=21<BR> else if not integerp(params.res) then res=21<BR> else if params.res&#060;2 then res=21<BR> else res=params.res<BR> <BR> <BR> if voidp(params&#091;#w&#093;) then w=200<BR> else if not integerp(params.w) and not floatp(params.w) then w=200<BR> else w=params.w<BR> <BR> if voidp(params&#091;#h&#093;) then h=200<BR> else if not integerp(params.h) and not floatp(params.h) then h=200<BR> else h=params.h<BR> <BR> -- create text member to copy text from<BR> textmem=new(#text)<BR> textmem.font="arial"<BR> textmem.fontsize=10<BR> textmem.width=100<BR> textmem.alignment=#center<BR> <BR> im=image(w+bord*2,h+bord*2,16)<BR> <BR> leftX=min(minX,0)<BR> rightX=max(maxX,0)<BR> topY=max(maxY,0)<BR> bottomY=min(minY,0)<BR> xScale = w / (rightX - leftX)<BR> yScale = h / (topY - bottomY)<BR> -- draw axes<BR> x0 = xScale * (-leftX)<BR> y0 = yScale * (-bottomY)<BR> -- x0 and y0 are the positions within the graph of the axes<BR> -- add label at origin<BR> <A HREF="graphs.html#drawtext">drawtext</A>(im, "0", point(x0-5,y0-5), bord, textmem)<BR> -- draw y-axis<BR> <A HREF="graphs.html#drawline">drawline</A>(im,point(x0, 0), point(x0, h), bord)<BR> -- add arrow to top<BR> <A HREF="graphs.html#drawline">drawline</A>(im, point(x0,h), point(x0-5, h-7), bord)<BR> <A HREF="graphs.html#drawline">drawline</A>(im, point(x0,h), point(x0+5, h-7), bord)<BR> -- add label<BR> <A HREF="graphs.html#drawtext">drawtext</A>(im, "y", point(x0+5,h+5), bord, textmem)<BR> -- add scale<BR> -- calculate sensible increments<BR> mx=max(topY,abs(bottomY))<BR> lg=log(mx)/log(10)<BR> if integer(lg)&#062;lg then p=integer(lg)-1<BR> else p=integer(lg)<BR> n=mx/power(10,p)<BR> sc=power(10,p)<BR> if n&#060;2 then <BR> p=p-1<BR> sc=sc/10<BR> n=n*10<BR> else if n&#060;8 then<BR> p=p-1<BR> sc=sc/2<BR> n=n*2<BR> end if<BR> -- choose whether to alternate text labels<BR> if n&#062;8 then alt=0<BR> else alt=1<BR> -- write labels with sensible float precision<BR> the floatprecision=min(0,p)<BR> <BR> -- draw scale above origin<BR> y=sc<BR> d=0<BR> repeat while y&#060;=topY<BR> <A HREF="graphs.html#drawline">drawline</A>(im, point(x0-3, y0+y*yScale), point(x0, y0+y*yScale), bord)<BR> if d or alt then <A HREF="graphs.html#drawtext">drawtext</A>(im, string(y), point(x0-10, y0+y*yScale), bord, textmem)<BR> y=y+sc<BR> d=not d<BR> end repeat<BR> -- draw scale below origin<BR> y=-sc<BR> d=0<BR> repeat while y&#062;=bottomY<BR> <A HREF="graphs.html#drawline">drawline</A>(im, point(x0-3, y0+y*yScale), point(x0, y0+y*yScale), bord)<BR> if d or alt then <A HREF="graphs.html#drawtext">drawtext</A>(im, string(y), point(x0-10, y0+y*yScale), bord, textmem)<BR> y=y-sc<BR> d=not d<BR> end repeat<BR> <BR> <A HREF="graphs.html#drawline">drawline</A>(im,point(0, y0), point(w, y0), bord) -- x-axis<BR> -- add arrow to right<BR> <A HREF="graphs.html#drawline">drawline</A>(im, point(w, y0), point(w-7, y0+5), bord)<BR> <A HREF="graphs.html#drawline">drawline</A>(im, point(w, y0), point(w-7, y0-5), bord)<BR> -- add label<BR> <A HREF="graphs.html#drawtext">drawtext</A>(im, "x", point(w+6,y0), bord, textmem)<BR> -- add scale<BR> -- calculate sensible increments<BR> mx=max(rightX,abs(leftX))<BR> lg=log(mx)/log(10)<BR> if integer(lg)&#062;lg then p=integer(lg)-1<BR> else p=integer(lg)<BR> n=mx/power(10,p)<BR> sc=power(10,p)<BR> if n&#060;6 then<BR> p=p-1<BR> sc=sc/2<BR> n=n*2<BR> end if<BR> -- choose whether to alternate text labels<BR> if n&#062;4 then al=0<BR> else al=1<BR> -- write labels with sensible float precision<BR> the floatprecision=min(0,p)<BR> <BR> -- draw scale to right of origin<BR> x=sc<BR> d=0<BR> repeat while x&#060;=rightX<BR> <A HREF="graphs.html#drawline">drawline</A>(im, point(x0+x*xScale, y0-3), point(x0+x*xScale, y0), bord)<BR> if d or al then <A HREF="graphs.html#drawtext">drawtext</A>(im, string(x), point(x0+x*xScale, y0-10), bord, textmem)<BR> x=x+sc<BR> d=not d<BR> end repeat<BR> -- draw scale to left of origin<BR> x=-sc<BR> d=0<BR> repeat while x&#062;=leftX<BR> <A HREF="graphs.html#drawline">drawline</A>(im, point(x0+x*xScale, y0-3), point(x0+x*xScale, y0), bord)<BR> if d or al then <A HREF="graphs.html#drawtext">drawtext</A>(im, string(x), point(x0+x*xScale, y0-10), bord, textmem)<BR> x=x-sc<BR> d=not d<BR> end repeat<BR> <BR> -- -- plot gradient lines of the functions<BR> xspacing = (maxX - minX) / float(res - 1)<BR> yspacing = (maxY - minY) / float(res - 1)<BR> <BR> repeat with i=1 to res<BR> x1=random(res)*(maxx-minx)/res+minx<BR> y1=random(res)*(maxy-miny)/res+miny<BR> d=<A HREF="algebra.html#calculateValue">calculateValue</A>(functionToDraw,x1, y1)<BR> if d=#infinite then <BR> p1=0<BR> p2=yspacing<BR> else if d&#060;&#062;#undefined then<BR> p=point(1.0,d)<BR> len=sqrt(1.0+d*d)<BR> p=p/len<BR> p1=p&#091;1&#093;*xspacing<BR> p2=p&#091;2&#093;*yspacing<BR> else<BR> next repeat<BR> end if<BR> x2=x1-p1<BR> y2=y1-p2<BR> pts=&#091;point(x1,y1),point(x2,y2)&#093;<BR> repeat with j=1 to res<BR> repeat with k=1 to 2<BR> pt=pts&#091;k&#093;<BR> d=<A HREF="algebra.html#calculate2DValue">calculate2DValue</A>(functionToDraw,pt&#091;1&#093;, pt&#091;2&#093;)<BR> if d=#infinite then <BR> p1=0<BR> p2=yspacing<BR> else if d&#060;&#062;#undefined then<BR> p=point(1.0,d)<BR> len=sqrt(1.0+d*d)<BR> p=p/len<BR> p1=p&#091;1&#093;*xspacing<BR> p2=p&#091;2&#093;*yspacing<BR> else<BR> next repeat<BR> end if<BR> if k=1 then<BR> x=pt&#091;1&#093;+p1<BR> y=pt&#091;2&#093;+p2<BR> <A HREF="graphs.html#drawline">drawline</A>(im,point(pt&#091;1&#093;*xscale, pt&#091;2&#093;*yscale), point(x*xscale, y*yscale), bord)<BR> else<BR> x=pt&#091;1&#093;-p1<BR> y=pt&#091;2&#093;-p2<BR> <A HREF="graphs.html#drawline">drawline</A>(im,point(pt&#091;1&#093;*xscale, pt&#091;2&#093;*yscale), point(x*xscale, y*yscale), bord)<BR> end if<BR> pts&#091;k&#093;=point(x,y)<BR> <BR> end repeat<BR> end repeat<BR> end repeat <BR> -- create a cast member to display results<BR> m=new(#bitmap)<BR> m.image=im<BR> erase textmem<BR> return m<BR>end<BR><HR></KBD><P><A HREF="math index.html">Back to index</A></PRE></BODY></HTML> 