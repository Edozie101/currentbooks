<HTML><HEAD><TITLE>chapter 26 (genetic algorithms) functions</TITLE></HEAD><BODY><H2 ALIGN="center">Functions for cast member "chapter 26 (genetic algorithms)" of castlib "math"</H2><P><PRE><KBD><A NAME="mateOrganisms"> </A>on mateOrganisms (strand1, strand2, radiation)<BR> --! ARGUMENTS: strand1, strand2: genetic algorithm genomes (boolean lists of the same length)<BR> --! RETURNS: a new strand<BR> set child to &#091;&#093;<BR> set currentStrand to 1<BR> set strands to &#091;strand1, strand2&#093;<BR> set len to strand1.count<BR> repeat with i=1 to len<BR> -- randomly switch strands<BR> if random(len)&#060;5 then set currentStrand to 3-currentStrand <BR> set element to strands&#091;currentStrand&#093;&#091;i&#093;<BR> -- randomly mutate the occasional element<BR> if random(len)&#060;=radiation then set element to not(element)<BR> child.add(element)<BR> end repeat<BR> return child<BR>end <BR><HR><A NAME="randomPopulation"> </A>on randomPopulation (numOrganisms, genomeLength)<BR> --! ARGUMENTS: numOrganisms, genomeLength (positive integers)<BR> --! RETURNS: a list of random genomes<BR> set ret to &#091;&#093;<BR> repeat with i=1 to numOrganisms<BR> set gen to &#091;&#093;<BR> repeat with j=1 to genomeLength<BR> gen.add(random(1000)&#062;500)<BR> end repeat<BR> ret.add(gen)<BR> end repeat<BR> return ret<BR>end<BR><HR><A NAME="geneticAlgorithm"> </A>on geneticAlgorithm (population, evaluationObject, radiation)<BR> --! ARGUMENTS: population (list of genomes), evaluationObject (an object which can evaluate a particular genome)<BR> --! RETURNS: a revised population<BR> -- NB: assumes the utility function is to be minimized<BR> set popSize to population.count<BR> -- calculate the number of winners required to keep the population the same size<BR> set numWinners to (1+sqrt(1+8*popSize))/2<BR> set winners to &#091;&#093;<BR> set winningScores to &#091;&#093;<BR> sort winningScores<BR> repeat with strand in population<BR> -- evaluate each strand<BR> sc=evaluationObject.evaluate(strand)<BR> if sc&#060;0 then next repeat -- this allows us to discard badly-formed strands<BR> if winningScores.count=numWinners then<BR> -- if this strand is less good than the worst in the list then ignore it<BR> if sc&#062;winningScores&#091;numWinners&#093; then next repeat<BR> end if<BR> -- otherwise add it to the list<BR> winningScores.add(sc)<BR> pos=winningScores.getPos(sc)<BR> winners.addat(pos,strand)<BR> end repeat<BR> -- now mate the strands in pairs to produce a new population<BR> set newPop to &#091;&#093;<BR> repeat with i=1 to numWinners-1<BR> set s1 to ((i-1) mod winners.count)+1<BR> set strand1 to winners&#091;s1&#093;<BR> repeat with j=i+1 to numWinners<BR> set s2 to ((j-1) mod winners.count)+1<BR> set strand2 to winners&#091;s2&#093;<BR> newPop.add(<A HREF="chapter 26.html#mateOrganisms">mateOrganisms</A>(strand1, strand2, radiation))<BR>-- newPop.add(<A HREF="chapter 26.html#mateOrganisms">mateOrganisms</A>(strand1, strand2, radiation))<BR> end repeat<BR> end repeat<BR> return newPop<BR>end<BR><HR></KBD><P><A HREF="math index.html">Back to index</A></PRE></BODY></HTML> 