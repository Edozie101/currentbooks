<HTML><HEAD><TITLE>collision (pool) functions</TITLE></HEAD><BODY><H2 ALIGN="center">Functions for cast member "collision (pool)" of castlib "pool"</H2><P><PRE><KBD><A NAME="moveballs"> </A>on moveballs t, table, cushions, pockets, balls, r, res, e, withspin, kineticFriction<BR> -- res is the constant air resistance factor reducing linear speed; <BR> -- the kinetic friction term only affects motion with spin<BR> -- we ignore static friction<BR> <BR> -- apply friction and deactivate where appropriate<BR> hit=0<BR> mv=0<BR> repeat with b in balls<BR> if b.moving then<BR> -- check if it is actually moving<BR> if b.speed=0 and b.staticfr then <BR> b.moving=0<BR> -- nb: side spin is allowed to continue until the turn ends<BR> else<BR> -- apply linear friction term<BR> b.speed=max(b.speed-res*t,0)<BR> -- calculate kinetic friction for balls which are not rolling with static friction<BR> if not b.staticfr then -- note that staticfr is always 1 if there is no spin<BR> -- topspin is assumed to be in units such that 1 unit of topspin equates to 1 unit of linear speed<BR> <BR> -- calculate relative velocity of ball against table surface<BR> spinDifference= b.speed*b.dir-b.topspin*b.spindir<BR> fric=mag(spinDifference)<BR> -- apply an impulse along the line of the spin difference<BR> if fric&#060;kineticFriction*t then<BR> -- spin matches ball speed: switch to static friction<BR> b.staticfr=1<BR> b.topspin=b.speed<BR> b.spindir=b.dir<BR> else <BR> J=kineticFriction*t*spinDifference/fric<BR> v=b.speed*b.dir-J<BR> b.speed=mag(v)<BR> if b.speed&#062;0 then<BR> b.dir=v/b.speed<BR> end if<BR> -- decrease amount of topspin<BR> if dotprod(spinDifference,b.spindir)&#062;0 then<BR> b.topspin=b.topspin+mag(J)<BR> else<BR> b.topspin=b.topspin-mag(J)<BR> end if<BR> -- b.spindir=spinDifference/fric<BR> end if<BR> else<BR> -- static friction is active: match topspin to speed<BR> if withspin then b.topspin=b.speed<BR> end if<BR> <BR> end if<BR> mv=1<BR> end if<BR> end repeat<BR> if mv=0 then return #stopped<BR> -- check for collisions<BR> repeat while true<BR> mn=2<BR> ob1=0<BR> ob2=0<BR> repeat with i=balls.count down to 1<BR> b1=balls&#091;i&#093;<BR> if b1.potted then next repeat<BR> v=b1.speed*b1.dir*t<BR> -- check for collisions between balls<BR> repeat with j=i-1 down to 1<BR> b2=balls&#091;j&#093;<BR> if b2.potted then next repeat<BR> if b1.moving or b2.moving then<BR> u=b2.speed*b2.dir*t<BR> c=<A HREF="detection.html#ballBallCollision">ballBallCollision</A>(b1.pos,v,r,b2.pos,u,r)<BR> if not listp(c) then next repeat<BR> tm=c.t<BR> m=min(mn,tm)<BR> if m&#060;mn then <BR> mn=m<BR> n=c.normal<BR> ob1=b1<BR> ob2=b2<BR> tp=#ball<BR> end if<BR> end if<BR> <BR> end repeat<BR> -- check for collisions with walls and pocket entrances<BR> if b1.moving then<BR> repeat with w in table<BR> <BR> c=<A HREF="detection.html#ballCushionCollision">ballCushionCollision</A>(r,b1.pos,v,w&#091;1&#093;,w&#091;2&#093;, w&#091;3&#093;)<BR> if not listp(c) then next repeat<BR> tm=c.t<BR> m=min(mn,tm)<BR> if m&#060;mn then <BR> mn=m<BR> n=c.normal<BR> ob1=b1<BR> tp=#wall<BR> end if<BR> <BR> end repeat<BR> repeat with p in cushions&#091;1&#093;<BR> c=<A HREF="detection.html#ballBallCollision">ballBallCollision</A>(b1.pos,v,r,p,point(0,0),cushions&#091;2&#093;)<BR> if not listp(c) then next repeat<BR> tm=c.t<BR> m=min(mn,tm)<BR> if m&#060;mn then <BR> mn=m<BR> n=c.normal<BR> ob1=b1<BR> tp=#wall<BR> end if<BR> <BR> end repeat<BR> -- and with pockets<BR> repeat with p in pockets<BR> c=<A HREF="detection.html#pointBallCollision">pointBallCollision</A>(p-b1.pos,-v,r)<BR> if not listp(c) then next repeat<BR> tm=c.t<BR> m=min(mn,tm)<BR> if m&#060;mn then <BR> mn=m<BR> ob1=b1<BR> tp=#pot<BR> end if<BR> <BR> end repeat<BR> end if<BR> end repeat<BR> <BR> if mn=2 then exit repeat<BR> <BR> -- there is a collision<BR> <BR> -- move balls<BR> repeat with b in balls<BR> b.pos=b.pos+b.speed*mn*t*b.dir<BR> end repeat<BR> -- resolve collision<BR> if tp=#wall then <BR> u=ob1.dir<BR> if withspin then <BR> res=<A HREF="resolution.html#resolveSpinningPoolCushionCollision">resolveSpinningPoolCushionCollision</A>(ob1.dir*ob1.speed,ob1.side,e,r,n,0.2)<BR> <BR> ob1.side=res&#091;2&#093;<BR> res=res&#091;1&#093;<BR> else <BR> res=<A HREF="resolution.html#resolvePoolCushionCollision">resolvePoolCushionCollision</A>(ob1.dir*ob1.speed,e,n)<BR> end if<BR> ob1.speed=mag(res)<BR> if ob1.speed&#062;0 then ob1.dir=res/ob1.speed<BR> <BR> --resolveInelasticCollisionFixed(u,e,e,n)<BR> else if tp=#pot then<BR> ob1.potted=1<BR> ob1.moving=0<BR> else<BR> u1=ob1.dir*ob1.speed<BR> u2=ob2.dir*ob2.speed<BR> <BR> res=<A HREF="resolution.html#resolvePoolCollision">resolvePoolCollision</A>(u1,u2,n)<BR> ob1.speed=mag(res&#091;1&#093;)<BR> if ob1.speed&#062;0 then ob1.dir=res&#091;1&#093;/ob1.speed<BR> ob2.speed=mag(res&#091;2&#093;)<BR> if ob2.speed&#062;0 then ob2.dir=res&#091;2&#093;/ob2.speed<BR> if withspin then<BR> if not ob1.moving then ob1.spindir=ob1.dir<BR> if not ob2.moving then ob2.spindir=ob2.dir<BR> ob1.staticfr=0<BR> ob2.staticfr=0<BR> end if<BR> ob1.moving=1<BR> ob2.moving=1<BR> if hit=0 then<BR> hit=ob1.color<BR> if hit=#cue then hit=ob2.color<BR> end if<BR> <BR> end if<BR> -- decrease time and repeat<BR> t=t*(1-mn)<BR> end repeat<BR> -- move balls<BR> repeat with b in balls<BR> b.pos=b.pos+b.speed*t*b.dir<BR> end repeat<BR> return hit<BR>end<BR><HR></KBD><P><A HREF="pool index.html">Back to index</A></PRE></BODY></HTML> 