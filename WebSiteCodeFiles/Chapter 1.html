<HTML><HEAD><TITLE>Chapter 1 (numbers, floats and bases) functions</TITLE></HEAD><BODY><H2 ALIGN="center">Functions for cast member "Chapter 1 (numbers, floats and bases)" of castlib "math"</H2><P><PRE><KBD><A NAME="NumberToBaseString"> </A>on NumberToBaseString (Number, <A HREF="Floats.html#Base">Base</A>) <BR> --! ARGUMENTS: Number (an integer); <A HREF="Floats.html#Base">Base</A> (an integer greater than 1)<BR> --! RETURNS: A string (the number Number in the <A HREF="Floats.html#base">base</A> <A HREF="Floats.html#Base">Base</A>)<BR> -- First check if Number is negative, and if so then switch to the positive and add a minus sign<BR> If Number&#060;0 then return "-"&NumberToBaseString(-Number, <A HREF="Floats.html#Base">Base</A>)<BR> -- If Number is less than <A HREF="Floats.html#Base">Base</A> then return the Number (as a string)<BR> if Number&#060;<A HREF="Floats.html#Base">Base</A> then <BR> return String (Number)<BR> else<BR> -- Find the remainder Rem when you divide Number by <A HREF="Floats.html#Base">Base</A><BR> set Rem to Number mod <A HREF="Floats.html#Base">Base</A><BR> -- Reduce the number by Rem and divide by <A HREF="Floats.html#Base">Base</A> <BR> set ReducedNumber to (Number - Rem) / <A HREF="Floats.html#Base">Base</A><BR> -- Recurse by finding the NumberToBaseString of the reduced number<BR> set RestOfString to NumberToBaseString (ReducedNumber, <A HREF="Floats.html#Base">Base</A>)<BR> -- Put Rem at the end of this string and return it<BR> return RestOfString&Rem<BR> end if<BR>end <BR><HR><A NAME="BaseStringToValue"> </A>on BaseStringToValue (DigitString, <A HREF="Floats.html#Base">Base</A>)<BR> --! ARGUMENTS: DigitString (a string of digits); <A HREF="Floats.html#Base">Base</A> (an integer between 2 and 10)<BR> --! RETURNS: An integer (the string of digits converted to an integer - note that this has no <A HREF="Floats.html#base">base</A><BR> --! even though it will be displayed in <A HREF="Floats.html#base">base</A> 10)<BR> -- If DigitString is one digit then return that digit<BR> if DigitString.length&#060;=1 then <BR> return value(digitString)<BR> else<BR> -- set Output to the last digit of DigitString<BR> set Output to value(the last char of DigitString)<BR> if output&#062;(<A HREF="Floats.html#base">base</A>-1) then return #error<BR> -- set RemainingString to all but the last digit of DigitString and recurse to find its value<BR> set RemainingString to DigitString.char&#091;1..DigitString.length-1&#093;<BR> set ValueOfRemainingString to BaseStringToValue (RemainingString, <A HREF="Floats.html#Base">Base</A>)<BR> if ValueOfRemainingString=#error then return #error<BR> -- add <A HREF="Floats.html#Base">Base</A> * ValueOfRemainingString to Output and return it<BR> return Output+<A HREF="Floats.html#Base">Base</A>*ValueOfRemainingString<BR> end if<BR>end <BR><HR><A NAME="AddBinaryStrings"> </A>on AddBinaryStrings (b1, b2) <BR> --! ARGUMENTS: b1, b2 (strings of 1s and 0s)<BR> --! RETURNS: A binary string (sum of b1 and b2)<BR> -- pad out the smaller number with leading zeroes so they are the same length<BR> repeat while b1.length&#060;b2.length<BR> b1="0"&b1<BR> end repeat<BR> repeat while b2.length&#060;b1.length<BR> b2="0"&b2<BR> end repeat<BR> <BR> set Output to ""<BR> set CarryDigit to 0<BR> -- working from the end of b1 to the beginning<BR> repeat with Index = b1.length down to 1<BR> -- set k1 and k2 to the index'th character of b1 and b2<BR> set k1 to value(b1.char&#091;index&#093;)<BR> set k2 to value(b2.char&#091;index&#093;)<BR> -- if the digits are the same, write the current carry digit<BR> if k1 = k2 then <BR> set WriteDigit to CarryDigit<BR> -- and set the carry digit to the value of k1<BR> set CarryDigit to k1 <BR> -- otherwise write the opposite of the current carry digit<BR> else<BR> set WriteDigit to NOT(CarryDigit)<BR> -- and leave the carry digit alone as it will be unchanged<BR> end if<BR> -- append WriteDigit to the front of Output<BR> set output to writeDigit&Output<BR> end repeat<BR> -- Finally, if the last carryDigit is 1, then put it on the front of Output<BR> if CarryDigit = 1 then Output=1&Output<BR> return output<BR>end <BR><HR><A NAME="SubtractBinaryStrings"> </A>on SubtractBinaryStrings (b1, b2) <BR> --! ARGUMENTS: b1, b2 (strings of 1s and 0s)<BR> --! RETURNS: A binary string (positive difference of b1 and b2)<BR> -- ensure b1&#062;b2<BR> if <A HREF="Chapter 1.html#bingreater">bingreater</A>(b2,b1) then<BR> a=b2<BR> b2=b1<BR> b1=a<BR> end if<BR> -- pad out b2 with leading zeroes to the same length as b1<BR> repeat while b2.length&#060;b1.length<BR> b2="0"&b2<BR> end repeat<BR> -- set Output to an empty string and borrow to 0<BR> Output=""<BR> borrow=0<BR> -- working backwards through b1<BR> repeat with Index = b1.length down to 1<BR> -- set k1 and k2 to the index'th character of b1 and b2<BR> set k1 to value(b1.char&#091;index&#093;)<BR> set k2 to value(b2.char&#091;index&#093;)<BR> -- if borrow is 1 then <BR> if borrow then<BR> -- set k1 to not k1<BR> k1=not k1<BR> -- if k1 is now 0 then we've found a digit to borrow<BR> if k1=0 then borrow=0<BR> end if<BR> -- If k1 and k2 are the same then append 0 to the front of output<BR> -- otherwise append 1, and if k1 is 0 then set borrow to 1<BR> if k1=k2 then<BR> k=0<BR> else <BR> k=1<BR> if k1=0 then borrow=1<BR> end if<BR> <BR> output=k&output<BR> end repeat<BR> -- Finally, remove all leading 0's<BR> repeat while output.char&#091;1&#093;="0"<BR> delete output.char&#091;1&#093;<BR> end repeat<BR> -- and if the whole thing is 0 then return 0<BR> if output.length=0 then return "0"<BR> return output<BR>end<BR><HR><A NAME="bingreater"> </A>on bingreater b1, b2, eq <BR> --! ARGUMENTS: b1, b2 (strings of 1s and 0s); eq (boolean)<BR> --! RETURNS: 1 if b1&#062;b2,0 otherwise; if eq is true then 1 for b1&#062;=b2<BR> -- Remove leading 0's<BR> repeat while b1.char&#091;1&#093;="0"<BR> delete b1.char&#091;1&#093;<BR> end repeat<BR> repeat while b2.char&#091;1&#093;="0"<BR> delete b2.char&#091;1&#093;<BR> end repeat<BR> -- Return 1 if b1 is longer than b2, 0 if shorter<BR> if b1.length&#062;b2.length then return 1<BR> if b1.length&#060;b2.length then return 0<BR> -- work forwards through b1<BR> repeat with Index = 1 to b1.length<BR> -- set k1 and k2 to the index'th character of b1 and b2<BR> set k1 to b1.char&#091;index&#093;<BR> set k2 to b2.char&#091;index&#093;<BR> -- if k1 is not k2 then return k1<BR> if k1&#060;&#062;k2 then return value(k1)<BR> end repeat<BR> -- if we get to the end of the loop then the numbers are equal<BR> if eq then return 1<BR> return 0<BR> <BR>end<BR><HR></KBD><P><A HREF="math index.html">Back to index</A></PRE></BODY></HTML> 