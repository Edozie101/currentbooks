<HTML><HEAD><TITLE>Chapter 24 (mazes) functions</TITLE></HEAD><BODY><H2 ALIGN="center">Functions for cast member "Chapter 24 (mazes)" of castlib "math"</H2><P><PRE><KBD><A NAME="visibleSquares"> </A>on visibleSquares (maze, observerPoint, beamStartAngle, beamEndAngle, fromSquare, thisSquare)<BR> --! ARGUMENTS: maze (an object with details of the maze)<BR> --! observerPoint (2D vector), beamStartAngle, beamEndAngle (numbers between -pi and pi), <BR> --! fromSquare, thisSquare (square numbers of the current square and the square we're coming from)<BR> --! RETURNS: a list of all squares at least partially visible from the current position.<BR> <BR> -- set default values<BR> if voidp(beamstartangle) then <BR> set beamStartAngle to -pi<BR> set beamEndAngle to pi<BR> end if<BR> if voidp (thisSquare) then<BR> set thisSquare to maze.pointToSquare(observerPoint)<BR> if thisSquare=0 then return &#091;&#093;<BR> end if<BR> -- include the current square<BR> set ret to &#091;&#093;<BR> ret.add(thisSquare)<BR> -- find list of neighbors of the square<BR> neigh=maze.neighbors(thisSquare)<BR> -- for each neighbor<BR> repeat with n in neigh<BR> -- (except the one we came from)<BR> if n=fromsquare then next repeat<BR> -- find the position of the 'doorway' vertices<BR> set d to maze.doorway(n,thisSquare)<BR> if d=0 then next repeat -- if there is no doorway then ignore<BR> set v1 to d&#091;1&#093; -- first vertex <A HREF="energy, momentum.html#clockwise">clockwise</A><BR> set v2 to d&#091;2&#093; -- second vertex <A HREF="energy, momentum.html#clockwise">clockwise</A><BR> -- find the angles from the observer to each vertex<BR> set a1 to <A HREF="2D vectors.html#angleOf">angleOf</A>(v1-observerPoint)<BR> set a2 to <A HREF="2D vectors.html#angleOf">angleOf</A>(v2-observerPoint)<BR> -- if either vertex is visible then<BR> if (a1&#060;beamstartangle or a1&#062;beamendangle) and (a2&#060;beamstartangle or a2&#062;beamendangle) then next repeat<BR> if a1&#060;a2 then -- vertices are on the same side of the angle range<BR> set start to max(a1, beamStartAngle)+0.02 -- the increment is added to rule out 'just visible' squares<BR> set finish to min(a2, beamEndAngle)-0.02<BR> -- recurse over all visible squares<BR> set s to visibleSquares(maze, observerPoint, start, finish, thisSquare, n)<BR> -- add all visible squares along the path to ret<BR> repeat with sq in s<BR> ret.add(sq)<BR> end repeat<BR> else<BR> -- the doorway 'straddles' the angle range<BR> set start to min(a1, beamEndAngle)+0.02<BR> set finish to max(a2, beamStartAngle)-0.02<BR> -- split the angle range into two parts<BR> set s1 to visibleSquares(maze, observerPoint, finish, pi, thisSquare, n)<BR> set s2 to visibleSquares(maze, observerPoint, -pi, start, thisSquare, n)<BR> -- recurse along both paths<BR> repeat with s in &#091;s1,s2&#093;<BR> repeat with sq in s<BR> ret.add(sq)<BR> end repeat<BR> end repeat<BR> <BR> end if<BR> end repeat<BR> return ret<BR>end <BR><HR><A NAME="astar"> </A>on astar (maze, start, goal)<BR> --! ARGUMENTS: maze (a maze object), start, goal (square numbers)<BR> set pathList to &#091;&#093;<BR> set d to maze.straightDistance(start, goal)<BR> pathlist.add( &#091;d, 0, start&#093; )<BR> -- sort pathList by estimated distance to goal<BR> pathlist.sort() -- Lingo sorts automatically on the first element of a list<BR> repeat while true<BR> set path to pathList&#091;1&#093;<BR> -- extend each path to all possible neighbors<BR> pathList.deleteat(1)<BR> set currentSquare to path&#091;path.count&#093; -- the last square of path<BR> set previousSquare to path&#091;path.count-1&#093; -- the second-to-last square of path if any <BR> set neigh to maze.neighbors(currentSquare, 1)<BR> -- repeat for each accessible neighbor of currentSquare<BR> repeat with n in neigh<BR> -- except previousSquare<BR> if n=previousSquare then next repeat<BR> set p to path.duplicate()<BR> set pth to path.duplicate()<BR> p.deleteat(1) <BR> p.deleteat(1) -- we don't want to count the distance as a potential square<BR> if not p.getOne(n) then <BR> -- neighbor is not an element of p: no loop<BR> -- append neighbor to path<BR> pth.add(n)<BR> <BR> set pth&#091;2&#093; to pth&#091;2&#093;+1 -- length of path<BR> set pth&#091;1&#093; to pth&#091;2&#093;+maze.straightDistance(n, goal) -- distance underestimate <BR> pathlist.add(pth) -- retaining the sort on element 1<BR> end if<BR> end repeat<BR> if pathList.count=0 then return "No path to goal"<BR> if pathList&#091;1&#093;&#091;pathlist&#091;1&#093;.count&#093;=goal then return pathList&#091;1&#093;<BR> end repeat<BR>end <BR><HR></KBD><P><A HREF="math index.html">Back to index</A></PRE></BODY></HTML> 