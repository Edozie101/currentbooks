<HTML><HEAD><TITLE>chapter 5 (vectors) functions</TITLE></HEAD><BODY><H2 ALIGN="center">Functions for cast member "chapter 5 (vectors)" of castlib "math"</H2><P><PRE><KBD><A NAME="createA"> </A>on createA legLength, angleAtTop, serifProp, crossbarProp, crossbarHeight, serifAlign, crossbarAlign<BR> --! ARGUMENTS: legLength (pixels), angleAtTop (degrees), serifProp, crossbarProp, crossbarHeight, serifAlign, crossbarAlign (fractions)<BR> --! RETURNS: an image object with the appropriate A.<BR> set halfAngle to angleAtTop*pi/360<BR> -- set leg vectors<BR> set leftLeg to legLength*point(-sin(halfAngle), cos(halfAngle)) <BR> set rightLeg to point(-leftLeg&#091;1&#093;, leftLeg&#091;2&#093;)<BR> -- set key points<BR> set crossbarStart to leftLeg*crossbarHeight<BR> set crossbarEnd to rightLeg*crossbarHeight<BR> set crossbar to crossbarProp*(crossbarEnd-crossbarStart)<BR> set crossbarStart to crossbarStart+ crossbarAlign*(1-crossbarProp)*(crossbarEnd-crossbarStart) <BR> set serif to serifProp*(rightLeg-leftLeg)<BR> set serifOffset to serifAlign*serif<BR> set st to point(rightLeg&#091;1&#093;+serifOffset&#091;1&#093;,3)<BR> -- set up image object<BR> set im to image(rightLeg&#091;1&#093;*2+serif&#091;1&#093;,leftLeg&#091;2&#093;+5,32)<BR> set col to rgb(0,0,0)<BR> -- draw lines<BR> im.draw( st, st+leftLeg,col)<BR> im.draw(st, st+rightLeg,col)<BR> im.draw(st+crossbarStart, st+crossbarStart+crossbar,col)<BR> im.draw(st+leftLeg-serifOffset, st+leftLeg-serifOffset+serif,col)<BR> im.draw(st+rightLeg-serifOffset, st+rightLeg-serifOffset+serif,col)<BR> return im<BR>end <BR><HR><A NAME="curvedPath"> </A>on curvedPath endPoint, currentPoint, speed, normalProportion, timeStep<BR> --! ARGUMENTS: endPoint, currentPoint (2D vectors), speed (pixels/time), normalProportion (fraction), timeStep (number) <BR> --! RETURNS: the new point<BR> set radius to endPoint-currentPoint<BR> -- if distance from endPoint is less than speed*timeStep then just go there<BR> if <A HREF="2D vectors.html#mag">mag</A>(radius)&#060;speed*timeStep then <BR> return #stop<BR> -- otherwise<BR> else<BR> -- calculate radial and tangential components<BR> set radialComponent to <A HREF="2D vectors.html#norm">norm</A>(radius)<BR> set tangentialComponent to <A HREF="2D vectors.html#normalVector">normalVector</A>(radialComponent)*normalProportion<BR> set displacement to speed*timeStep*<A HREF="2D vectors.html#norm">norm</A>(radialComponent+tangentialComponent)<BR> return currentPoint+displacement<BR> end if<BR>end <BR><HR><A NAME="madPath"> </A>on madPath endPoint, currentPoint, currentAlpha, speed, alphaSpeed, timeStep<BR> --! ARGUMENTS: endPoint, currentPoint (2D vectors), currentAlpha (radians), speed (pixels/time), alphaSpeed (radians/sec^2), timeStep (number) <BR> --! RETURNS: the new point and Alpha value<BR> set radius to endPoint-currentPoint<BR> -- if distance from endPoint is less than speed*timeStep then just go there<BR> if <A HREF="2D vectors.html#mag">mag</A>(radius)&#060;speed*timeStep then <BR> return &#091;endPoint,#stop&#093;<BR> -- otherwise<BR> else<BR> -- calculate new radial and tangential components<BR> set radialComponent to <A HREF="2D vectors.html#norm">norm</A>(radius)<BR> set newAlpha to currentAlpha+alphaSpeed*timeStep<BR> set tangentialComponent to <A HREF="2D vectors.html#normalVector">normalVector</A>(radialComponent)*tan(newAlpha)<BR> -- calculate new velocity<BR> set vel to speed*timeStep*<A HREF="2D vectors.html#norm">norm</A>(radialComponent+tangentialComponent)<BR> return &#091;currentPoint+vel, newAlpha&#093;<BR> end if<BR>end<BR><HR><A NAME="drawCurvedPath"> </A>on drawCurvedPath endPoint, speed, normalProportion<BR> --! ARGUMENTS: endPoint (2D vector), speed (pixels/step), normalProportion (fraction) <BR> --! RETURNS: image object with the path<BR> -- just a routine to create sequential points on a curved path and<BR> -- draw them<BR> set l to &#091;point(0,0)&#093;<BR> set currentPoint to point(0,0)<BR> repeat while true<BR> set res to <A HREF="chapter 5.html#curvedPath">curvedPath</A>(endPoint, currentPoint, speed, normalProportion, 1)<BR> if res=#stop then <BR> l.add(endPoint)<BR> exit repeat<BR> else<BR> set currentPoint to res<BR> l.add(currentPoint)<BR> end if<BR> end repeat<BR> -- pass the list to <A HREF="chapter 5.html#drawPath">drawPath</A> to create the final image object<BR> return <A HREF="chapter 5.html#drawPath">drawPath</A>(l)<BR>end<BR><HR><A NAME="drawmadPath"> </A>on drawMadPath endPoint, speed, alphaSpeed<BR> --! ARGUMENTS: endPoint (2D vector), speed (pixels/step), alphaSpeed (radians/sec^2) <BR> --! RETURNS: image object with the path<BR> -- just a routine to create sequential points on a mad path and<BR> -- draw them<BR> set l to &#091;point(0,0)&#093;<BR> set currentPoint to point(0,0)<BR> set currentAlpha to 0<BR> repeat while true<BR> set res to <A HREF="chapter 5.html#madPath">madPath</A>(endPoint, currentPoint, currentAlpha, speed, alphaSpeed, 1)<BR> if res&#091;2&#093;=#stop then <BR> l.add(endPoint)<BR> exit repeat<BR> else<BR> set currentPoint to res&#091;1&#093;<BR> set currentAlpha to res&#091;2&#093;<BR> l.add(currentPoint)<BR> end if<BR> end repeat<BR> -- pass the list to <A HREF="chapter 5.html#drawPath">drawPath</A> to create the final image object<BR> return <A HREF="chapter 5.html#drawPath">drawPath</A>(l)<BR>end<BR><HR><A NAME="drawpath"> </A>on drawPath l<BR> --! ARGUMENTS: l (list of 2D vectors)<BR> --! RETURNS: an image object with the path of l<BR> if l.count=0 then return image(1,1,16)<BR> -- calculate maximum and minimum positions<BR> set maxx to l&#091;1&#093;&#091;1&#093;<BR> set minx to l&#091;1&#093;&#091;1&#093;<BR> set maxy to l&#091;1&#093;&#091;2&#093;<BR> set miny to l&#091;1&#093;&#091;2&#093;<BR> repeat with i=2 to l.count<BR> set pt to l&#091;i&#093;<BR> set maxx to max(pt&#091;1&#093;,maxx)<BR> set minx to min(pt&#091;1&#093;,minx)<BR> set maxy to max(pt&#091;2&#093;,maxy)<BR> set miny to min(pt&#091;2&#093;,miny)<BR> end repeat<BR> -- create an image object<BR> set im to image(maxx-minx,maxy-miny,16)<BR> set pt to point(minx,miny)<BR> -- draw the path<BR> repeat with i=2 to l.count<BR> im.draw(l&#091;i-1&#093;-pt,l&#091;i&#093;-pt,rgb(0,0,0))<BR> end repeat<BR> return im<BR>end<BR><HR></KBD><P><A HREF="math index.html">Back to index</A></PRE></BODY></HTML> 