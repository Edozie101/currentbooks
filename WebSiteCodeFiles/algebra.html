<HTML><HEAD><TITLE>algebra functions</TITLE></HEAD><BODY><H2 ALIGN="center">Functions for cast member "algebra" of castlib "math"</H2><P><PRE><KBD><A NAME="substitute"> </A>on substitute functionString, x<BR> --! ARGUMENTS: functionString (a string representing a function in x), x (the value for x to substitute)<BR> --! RETURNS: the result of substituting the correct value for x<BR> --! this version of the function can handle: <BR> --! terms in x, using the ^ symbol for exponents<BR> --! parenthetic expressions, recursively<BR> --! multiplying brackets and dividing expressions<BR> --! any other function, which should be in the form: func(expression)<BR> --! (the function name must not start with an 'x')<BR> --! it does not allow for any variable other than x<BR> x=float(x)<BR> <BR> -- shortcut for dealing with the string "x"<BR> if functionString="x" then return x<BR> -- shortcut for dealing with the empty string - NB, this always happens from within products<BR> if functionString="" then return 1<BR> -- shortcut for dealing with a plain number<BR> repeat with i=1 to functionString.length<BR> c=functionString.char&#091;i&#093;<BR> if not("1234567890-." contains c) then exit repeat<BR> if c="-" and i&#062;1 then exit repeat<BR> end repeat<BR> if i&#062;functionString.length then return value(functionString)<BR> <BR> -- begin by replacing all parenthetic terms recursively with the correct substitution:<BR> <BR> search=0<BR> fn=""<BR> repeat with i=1 to functionString.length<BR> c=functionString.char&#091;i&#093;<BR> if search=0 then <BR> -- copy the current character to the short function unless a new parenthetic expression<BR> if c="(" then <BR> search=1<BR> ex=""<BR> p=1<BR> else if c=")" then <BR> return "error" -- wrong syntax<BR> else<BR> if c&#060;&#062;" " then put c after fn<BR> end if<BR> else<BR> -- copy the current character to the current expression unless the parenthesis has been closed<BR> if c="(" then<BR> p=p+1<BR> put c after ex<BR> else if c=")" then<BR> p=p-1<BR> if p=0 then<BR> -- end of expression - recurse<BR> v=substitute(ex,x)<BR> if v="error" then return "error"<BR> put "("&v&")" after fn<BR> search=0<BR> else<BR> put c after ex<BR> end if<BR> else<BR> put c after ex<BR> end if<BR> end if<BR> end repeat<BR> <BR> if search then return "error" -- missing an end bracket<BR> <BR> -- the function should now have no expressions inside brackets, just single numbers<BR> -- separate out the function by additions and subtractions<BR> <BR> tot=0<BR> trm=0<BR> p=0<BR> ex=""<BR> repeat with i=1 to fn.length<BR> c=fn.char&#091;i&#093;<BR> if c="(" then <BR> p=1<BR> put c after ex<BR> else if c=")" then <BR> p=0<BR> put c after ex<BR> else if c="+" or (c="-" and p=0 and i&#062;1) then<BR> trm=1<BR> s=substitute(ex,x)<BR> if s="error" then return "error"<BR> tot=tot+s<BR> if c="-" then ex="-" -- leave the leading "-" for negative terms<BR> else ex=""<BR> else<BR> put c after ex<BR> end if<BR> end repeat<BR> if trm=1 then<BR> s=substitute(ex,x)<BR> if s="error" then return "error"<BR> tot=tot+s<BR> return tot -- we've solved it<BR> end if<BR> <BR> -- We now have an expression with no additions or subtractions<BR> <BR> -- look for a division (there should be at most one: "a/b/c" is ambiguous)<BR> the itemDelimiter="/" <BR> -- this is a lingo trick for separating strings by a particular delimiter<BR> if fn.item.count&#062;2 then return "error"<BR> if fn.item.count=2 then<BR> den=substitute(fn.item&#091;2&#093;,x)<BR> if den=0 or den="error" then return "error"<BR> the itemDelimiter="/" <BR> num=substitute(fn.item&#091;1&#093;,x)<BR> if num="error" then return "error"<BR> return num/den<BR> end if<BR> <BR> -- look for a function<BR> f=0<BR> ex=""<BR> repeat with i=1 to fn.length<BR> c=fn.char&#091;i&#093;<BR> if f=0 then -- looking for a function<BR> if "abcdefghijklmnopqrstuvwyz" contains c then<BR> func=c<BR> f=1<BR> <BR> else<BR> put c after ex<BR> end if<BR> else if f=1 then -- looking for the end of the function <BR> if c="(" then<BR> f=2<BR> val=""<BR> else if not ("abcdefghijklmnopqrstuvwyz" contains c) then <BR> return "error"<BR> else <BR> put c after func<BR> end if<BR> else -- looking for the value to insert<BR> if c=")" then<BR> f=0<BR> v=value(func&"("&val&")")<BR> if ex.length&#062;0 then<BR> -- check what comes before<BR> ch=ex.char&#091;ex.length&#093;<BR> if "0123456789x" contains ch then put "*" after ex<BR> end if<BR> put v after ex<BR> else<BR> put c after val<BR> end if<BR> end if<BR> end repeat<BR> if f&#060;&#062;0 then return "error"<BR> <BR> fn=ex<BR> -- the remaining string is some kind of product, possibly including exponents<BR> prod=1<BR> -- separate by "*"<BR> the itemDelimiter="*"<BR> if fn.item.count&#062;1 then<BR> repeat with i=1 to fn.item.count<BR> p=substitute(fn.item&#091;i&#093;,x)<BR> if p="error" then return "error"<BR> prod=prod*p<BR> end repeat<BR> return prod<BR> end if<BR> <BR> -- final multiplication - note that any exponent must be the last term<BR> term=""<BR> lastterm=""<BR> repeat with i=1 to fn.length<BR> c=fn.char&#091;i&#093;<BR> if c="(" then<BR> p=substitute(term,x)<BR> if p="error" then return "error"<BR> prod=prod*p<BR> term=""<BR> else if c=")" then<BR> if i=fn.length then exit repeat<BR> ch=fn.char&#091;i+1&#093;<BR> if ch="(" then next repeat<BR> p=substitute(term,x)<BR> if p="error" then return "error"<BR> <BR> if ch="^" then lastterm=p<BR> else prod=prod*p<BR> else if c="x" then<BR> p=substitute(term,x)<BR> if p="error" then return "error"<BR> prod=prod*p<BR> if i=fn.length then <BR> term="x"<BR> exit repeat<BR> end if<BR> <BR> ch=fn.char&#091;i+1&#093;<BR> if ch="^" then lastterm=x<BR> else prod=prod*x<BR> else if c="^" then<BR> if i=1 then return "error"<BR> if lastterm="" then<BR> pow=substitute(term,x)<BR> if pow="error" then return "error"<BR> <BR> else<BR> pow=lastterm<BR> end if<BR> <BR> ex=substitute(fn.char&#091;(i+1)..fn.length&#093;,x)<BR> if ex="error" then return "error"<BR> <BR> prod=prod*power(pow,ex)<BR> return prod<BR> else<BR> put c after term<BR> end if<BR> end repeat<BR> p=substitute(term,x)<BR> if p="error" then return "error"<BR> prod=prod*p<BR> <BR> return prod<BR>end <BR><HR><A NAME="calculatevalue"> </A>on calculatevalue (function,x,sub)<BR> --! ARGUMENTS: function (a string or handler name symbol), x (a number)<BR> --! RETURNS: the result of the function acting on x<BR> the floatprecision=-10<BR> -- If 'sub' is set to 1, then this simply returns the result of calculating the<BR> -- expression directly by substituting the value for "x". This will work<BR> -- for any function which Lingo would understand by itself, but not for<BR> -- 'special' expressions like ^.<BR> if sub then return value(function)<BR> if stringp(function) then <BR> -- only do this if the function is well defined <BR> -- for all values of x<BR> return <A HREF="algebra.html#substitute">substitute</A>(function, x)<BR> else<BR> return value(function&"("&x&")")<BR> end if<BR>end<BR><HR><A NAME="calculate2Dvalue"> </A>on calculate2Dvalue (function,x,y,sub)<BR> --! ARGUMENTS: function (a string or handler name symbol), x, y (numbers), sub (boolean: forces string substitution)<BR> --! RETURNS: the result of the function acting on x and y<BR> -- See above for an explanation of Sub.<BR> the floatprecision=-10<BR> if sub then return value(function)<BR> if stringp(function) then <BR> -- only do this if the function is well defined <BR> -- for all values of x<BR> return <A HREF="algebra.html#substitute">substitute</A>(function, x)<BR> else<BR> return value(function&"("&x&")")<BR> end if<BR>end<BR><HR></KBD><P><A HREF="math index.html">Back to index</A></PRE></BODY></HTML> 