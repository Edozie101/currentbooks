<HTML><HEAD><TITLE>chapter 18 (transforms) functions</TITLE></HEAD><BODY><H2 ALIGN="center">Functions for cast member "chapter 18 (transforms)" of castlib "math"</H2><P><PRE><KBD><A NAME="decomposeTransform"> </A>on decomposeTransform (trans) <BR> --! ARGUMENTS: trans (a 4x4 transform matrix)<BR> --! RETURNS: a list of position, rotation and scale vectors<BR> <BR> -- skim off translation<BR> set p to vector(trans&#091;1&#093;&#091;4&#093;, trans&#091;2&#093;&#091;4&#093;, trans&#091;3&#093;&#091;4&#093;)<BR> <BR> -- Calculate the rotation: z, y, x. The reverse order is required<BR> -- as a transform is rotated first around the x-axis, then around<BR> -- the y-axis and finally around the z-axis. To decompose the<BR> -- the rotations, we have to work backwards.<BR> <BR> -- Create constants for 90 degrees and 270 degrees in radians.<BR> -- All calculations will be performed in radians, then converted<BR> -- to degrees in a final step.<BR> <BR> a90 = pi / 2<BR> a270 = a90 * 3<BR> <BR> xx = trans&#091;1&#093;&#091;1&#093; -- x <A HREF="2D vectors.html#component">component</A> of x-axis<BR> xy = trans&#091;2&#093;&#091;1&#093; -- y <A HREF="2D vectors.html#component">component</A> of x-axis<BR> xz = trans&#091;3&#093;&#091;1&#093; -- z <A HREF="2D vectors.html#component">component</A> of x-axis<BR> <BR> if xx &#060;&#062; 0 then<BR> rz = atan(xy, xx)<BR> else if xy &#062; 0 then<BR> rz = a90<BR> else<BR> rz = a270<BR> end if<BR> <BR> -- Rotate by -rz around the z-axis, then use the x-axis position<BR> -- to determine the rotation around the y-axis.<BR> <BR> zSin = sin(-rz)<BR> zCos = cos(-rz)<BR> <BR> xx1 = (zCos * xx) - (zSin * xy) -- simplified from matrix maths<BR> -- xy1 = (zSin * xx) + (zCos * xy) -- 0<BR> -- xz is unchanged by a rotation around the z-axis<BR> <BR> if xx1 &#060;&#062; 0 then<BR> ry = -atan(xz, xx1)<BR> else if xz &#060; 0 then -- note reversed sign<BR> ry = a90<BR> else<BR> ry = a270<BR> end if<BR> <BR> -- Rotate by -ry around the y-axis, then use the y-axis position<BR> -- to determine the x-rotation.<BR> <BR> yx = trans&#091;1&#093;&#091;2&#093; -- x <A HREF="2D vectors.html#component">component</A> of y-axis<BR> yy = trans&#091;2&#093;&#091;2&#093; -- y <A HREF="2D vectors.html#component">component</A> of y-axis<BR> yz = trans&#091;3&#093;&#091;2&#093; -- z <A HREF="2D vectors.html#component">component</A> of y-axis<BR> <BR> -- Rotate the transform's y-axis by -rz around the z-axis<BR> yx1 = (zCos * yx) - (zSin * yy)<BR> yy1 = (zSin * yx) + (zCos * yy)<BR> -- yz unchanged<BR> <BR> -- Rotate the transform's y-axis by -ry around the y-axis<BR> ySin = sin(-ry)<BR> yCos = cos(-ry)<BR> <BR> -- yx2 = (yCos * yx1) + (ySin * yz) -- 0<BR> -- yy1 is unchanged by a rotation around the y-axis<BR> yz2 = (-ySin * yx1) + (yCos * yz)<BR> <BR> if yy1 &#060;&#062; 0 then<BR> rx = atan(yz2, yy1)<BR> else if yz2 &#062; 0 then<BR> rx = a90<BR> else<BR> rx = a270<BR> end if<BR> <BR> r = vector(rx, ry, rz) * 180 / pi<BR> <BR> -- Determine the scale from the magnitude of each of the three axes<BR> <BR> zx = trans&#091;1&#093;&#091;3&#093; -- x <A HREF="2D vectors.html#component">component</A> of z-axis<BR> zy = trans&#091;2&#093;&#091;3&#093; -- y <A HREF="2D vectors.html#component">component</A> of z-axis<BR> zz = trans&#091;3&#093;&#091;3&#093; -- z <A HREF="2D vectors.html#component">component</A> of z-axis<BR> <BR> sx = vector(xx, xy, xz).magnitude<BR> sy = vector(yx, yy, yz).magnitude<BR> sz = vector(zx, zy, zz).magnitude<BR> <BR> s = vector(sx, sy, sz) <BR> <BR> -- cross-check transform: ensures that the three<BR> -- calculated vectors do actually produce the same transform<BR> <BR> set check to <A HREF="chapter 18.html#makeTransform">makeTransform</A>(p, r, s)<BR> if not <A HREF="chapter 18.html#equaltransforms">equaltransforms</A>(trans,check) then<BR> return #invalid<BR> end if<BR> <BR> return &#091;p, r, s&#093;<BR>end <BR><HR><A NAME="makeTransform"> </A>on makeTransform (positionVector, rotationVector, scaleVector)<BR> --! ARGUMENTS: positionVector, rotationVector, scaleVector (all 3D vectors)<BR> --! RETURNS: 4x4 matrix combining the three transformations into a transform<BR> <BR> -- create a new transform<BR> set trans to <A HREF="chapter 18.html#blanktransform">blanktransform</A>()<BR> <BR> -- perform the three transformations<BR> set trans to <A HREF="chapter 18.html#scaletransform">scaletransform</A>(trans, scaleVector)<BR> set trans to <A HREF="chapter 18.html#rotatetransform">rotatetransform</A>(trans, rotationVector)<BR> set trans to <A HREF="chapter 18.html#translatetransform">translatetransform</A>(trans, positionVector)<BR> <BR> return trans<BR>end <BR><HR><A NAME="blanktransform"> </A>on blanktransform <BR> --! ARGUMENTS: none<BR> --! RETURNS: the identity transform<BR> m=&#091;&#093;<BR> repeat with i=1 to 4<BR> l=&#091;0,0,0,0&#093;<BR> l&#091;i&#093;=1<BR> m.add(l)<BR> end repeat<BR> return m<BR>end<BR><HR><A NAME="scaletransform"> </A>on scaletransform trans, vect<BR> --! ARGUMENTS: trans (a transform matrix), vect (a 3D scale vector)<BR> --! RETURNS: the transform scaled (NB: this changes the original transform)<BR> repeat with i=1 to 3<BR> repeat with j=1 to 4<BR> trans&#091;i&#093;&#091;j&#093;=trans&#091;i&#093;&#091;j&#093;*vect&#091;i&#093;<BR> end repeat<BR> end repeat<BR> return trans<BR>end<BR><HR><A NAME="translatetransform"> </A>on translatetransform trans, vect<BR> --! ARGUMENTS: trans (a transform matrix), vect (a 3D translation vector)<BR> --! RETURNS: the transform translated (NB: this changes the original transform)<BR> repeat with i=1 to 3<BR> trans&#091;i&#093;&#091;4&#093;=trans&#091;i&#093;&#091;4&#093;+vect&#091;i&#093;<BR> end repeat<BR> return trans<BR>end<BR><HR><A NAME="rotatetransform"> </A>on rotatetransform trans, rotationVector<BR> --! ARGUMENTS: trans (a transform matrix), vect (a 3D rotation vector, in degrees)<BR> --! RETURNS: the transform rotated (NB: this does not change the original transform)<BR> r=&#091;&#093;<BR> repeat with i=1 to 3<BR> ang=rotationvector&#091;i&#093;*pi/180<BR> s=sin(ang)<BR> c=cos(ang)<BR> m=&#091;&#093;<BR> row=0<BR> col=&#091;1,2,3&#093;<BR> col.deleteat(i)<BR> repeat with j=1 to 3<BR> l=&#091;0,0,0,0&#093;<BR> if j=i then l&#091;j&#093;=1<BR> else<BR> row=row+1<BR> if i=2 then k=1<BR> else k=-1<BR> if row=1 then <BR> l&#091;col&#091;1&#093;&#093;=c<BR> l&#091;col&#091;2&#093;&#093;=k*s<BR> else<BR> l&#091;col&#091;1&#093;&#093;=-k*s<BR> l&#091;col&#091;2&#093;&#093;=c<BR> end if<BR> end if<BR> m.add(l)<BR> end repeat<BR> m.add(&#091;0,0,0,1&#093;)<BR> r.add(m)<BR> end repeat<BR> repeat with i =1 to 3<BR> trans=<A HREF="matrices.html#matrixmultiply">matrixmultiply</A>(r&#091;i&#093;,trans)<BR> end repeat<BR> return trans<BR>end<BR><HR><A NAME="equaltransforms"> </A>on equaltransforms t1, t2<BR> --! ARGUMENTS: t1, t2 (transform matrices)<BR> --! RETURNS: true if t1 = t2, with a margin of error, false otherwise<BR> <BR> repeat with i=1 to 4<BR> repeat with j=1 to 4<BR> if abs(t1&#091;i&#093;&#091;j&#093;-t2&#091;i&#093;&#091;j&#093;)&#062;0.001 then return false<BR> end repeat<BR> end repeat<BR>end<BR><HR></KBD><P><A HREF="math index.html">Back to index</A></PRE></BODY></HTML> 