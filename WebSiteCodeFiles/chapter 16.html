<HTML><HEAD><TITLE>chapter 16 (oscillations) functions</TITLE></HEAD><BODY><H2 ALIGN="center">Functions for cast member "chapter 16 (oscillations)" of castlib "math"</H2><P><PRE><KBD><A NAME="calculateDHMparameters"> </A>on calculateDHMparameters (initialPos, initialVel, elasticity, damping)<BR> --! ARGUMENTS: initialPos, initialVel (numbers), elasticity, damping (positive numbers)<BR> --! RETURNS: a list of parameters for an oscillation, to be used in the <BR> --! <A HREF="chapter 16.html#getOscillatorPosition">getOscillatorPosition</A> and <A HREF="chapter 16.html#getOscillatorSpeed">getOscillatorSpeed</A> functions<BR> set omega to sqrt(elasticity)<BR> set d to damping/2<BR> set alpha to d*d-elasticity<BR> if d=0 then -- no damping: use SHM<BR> set p to atan(omega*initialPos,initialVel)<BR> set c to sqrt(elasticity * initialPos * initialPos + initialVel * initialVel)/omega<BR> return &#091;"SHM", p, c&#093;<BR> else if d&#060;omega then -- underdamped<BR> set v to initialVel + d * initialPos<BR> set p to atan(initialPos * omega, v)<BR> set s to initialPos * initialPos * elasticity + v * v<BR> set c to sqrt(s)/omega<BR> return &#091;"UnderDamped", p, c, sqrt(-alpha)&#093;<BR> else if d=omega then -- critical damping<BR> return &#091;"Critical", initialPos, omega * initialPos + initialVel&#093;<BR> else -- overdamping<BR> set sq to sqrt(alpha)<BR> set r1 to -d-sq<BR> set r2 to -d+sq<BR> set a to (r2*initialPos - initialVel)/(2*sq)<BR> set b to -(r1*initialPos - initialVel)/(2*sq)<BR> return &#091;"OverDamped", a, b, r1, r2&#093;<BR> end if<BR>end <BR><HR><A NAME="getOscillatorPosition"> </A>on getOscillatorPosition (elasticity, damping, params, time)<BR> --! ARGUMENTS: elasticity, damping (positive numbers), <BR> --! params (a list taken from the <A HREF="chapter 16.html#calculateDHMparameters">calculateDHMparameters</A> function), <BR> --! time (time from start of oscillation)<BR> --! RETURNS: the current position of the oscillator (as a number)<BR> set omega to sqrt(elasticity)<BR> set d to damping/2<BR> <BR> case params&#091;1&#093; of<BR> "SHM": return params&#091;3&#093; * sin(omega * time + params&#091;2&#093;)<BR> "UnderDamped": return params&#091;3&#093; * sin(params&#091;4&#093; * time + params&#091;2&#093;) * exp(-d * time)<BR> "Critical": return (params&#091;2&#093; + time * params&#091;3&#093;) * exp(-d*time)<BR> "OverDamped": return params&#091;2&#093; * exp(params&#091;4&#093;*time) + params&#091;3&#093; * exp(params&#091;5&#093;*time)<BR> end case<BR>end <BR><HR><A NAME="getOscillatorSpeed"> </A>on getOscillatorSpeed (elasticity, damping, params, time, pos)<BR> --! ARGUMENTS: elasticity, damping (positive numbers), <BR> --! params (a list taken from the <A HREF="chapter 16.html#calculateDHMparameters">calculateDHMparameters</A> function), <BR> --! time (time from start of oscillation), pos (current position as a number)<BR> --! RETURNS: the current velocity of the oscillator (as a number)<BR> <BR> -- determine pos before running this function <BR> set omega to sqrt(elasticity)<BR> set d to damping/2<BR> <BR> case params&#091;1&#093; of<BR> "SHM": return params&#091;3&#093; * omega * cos(omega * time + params&#091;2&#093;)<BR> "UnderDamped": return params&#091;3&#093; * omega * cos(params&#091;4&#093; * time + params&#091;2&#093;) * exp(-d * time) - d*pos<BR> "Critical": return params&#091;3&#093; * exp(-d*time) - d*pos<BR> "OverDamped": return params&#091;2&#093; * params&#091;4&#093; * exp(params&#091;4&#093;*time) + params&#091;3&#093; * params&#091;5&#093; * exp(params&#091;5&#093;*time)<BR> end case<BR>end <BR><HR><A NAME="particleOnSpring"> </A>on particleOnSpring (end1, end2, speed, direction, mass, totalEnergy, springLength, elasticity, compressive, timeStep, g)<BR> --! ARGUMENTS: end1, end2 (vector positions of two ends; end2 is the free particle), speed (speed of free particle),<BR> --! direction (direction of motion of free particle), mass (of free particle), <BR> --! totalEnergy (of system, or #unknown if not yet calculated), springLength (unstretched), elasticity (positive number), <BR> --! compressive (boolean), timeStep (length of time since last check), g (acceleration due to gravity (positive))<BR> --! RETURNS: List of position, speed, direction and total energy.<BR> <BR> set v to end1-end2<BR> set d to <A HREF="2D vectors.html#mag">mag</A>(v) -- length of spring<BR> set e to d-springLength -- extension<BR> <BR> if totalEnergy=#unknown then<BR> -- calculate current energy<BR> set totalEnergy to mass*speed*speed/2 <BR> if e&#062;0 or compressive=TRUE then<BR> set epe to elasticity*e*e/2<BR> set totalEnergy to totalEnergy + epe<BR> end if<BR> if g&#062;0 then<BR> set gpe to mass*g*end2&#091;2&#093;<BR> set totalEnergy to totalEnergy - gpe<BR> end if<BR> end if<BR> <BR> -- calculate force<BR> set f to point(0,mass*g) -- weight<BR> if e&#062;0 or compressive=TRUE then <BR> if d&#062;0 then<BR> set f to f+v*elasticity*e/d -- NB: v/d gives direction of spring<BR> end if<BR> end if<BR> <BR> -- calculate new position<BR> set a to f/mass <BR> set displacement to direction*speed*timeStep+a*timeStep*timeStep/2<BR> <BR> set pos to end2+displacement<BR> -- calculate new elastic energy<BR> set newd to <A HREF="2D vectors.html#mag">mag</A>(pos-end1) <BR> set newe to newd-springLength<BR> if newe&#062;0 or compressive=TRUE then<BR> set epe to elasticity*newe*newe/2<BR> else<BR> set epe to 0<BR> end if<BR> <BR> -- calculate new kinetic energy and hence speed<BR> set ke to totalEnergy-epe+mass*g*pos&#091;2&#093;<BR> if ke&#060;=0 then -- NB: for safety<BR> set speed to 0<BR> else<BR> set speed to sqrt(2*ke/mass)<BR> set velocity to <A HREF="2D vectors.html#norm">norm</A>(displacement)<BR> end if<BR> <BR> return &#091;pos,speed,velocity,totalEnergy&#093;<BR>end <BR><HR><A NAME="forceDueToSpring"> </A>on forceDueToSpring (end1, end2, velocity1, velocity2, \<BR>springLength, elasticity, damping, elasticLimit, \<BR>compressiveness, minLength)<BR> --! ARGUMENTS: end1, end2 (position vectors), velocity1, velocity2 (vectors), <BR> --! springlength (natural length), elasticity, damping (positive numbers), <BR> --! elasticLimit (maximum length), compressiveness (#loose, #rigid or #compressive)<BR> --! minLength (for compressive springs, the length at which they become rigid)<BR> --! RETURNS: the force vector on the particle due to the spring, or #bounce<BR> <BR> -- NB: the particle we're interested in is attached to end2 <BR> <BR> set v to end1-end2<BR> set d to <A HREF="2D vectors.html#mag">mag</A>(v)<BR> if d=0 then return point(0,0) -- just skip for this timestep if they coincide<BR> <BR> -- loose elastics have no force when compressed<BR> if d&#060;=springlength then<BR> if compressiveness=#loose then return point(0,0)<BR> end if<BR> <BR> -- apply second elastic limit (inextensible behavior)<BR> if d&#062;=elasticLimit*1.2 or d&#060;=minLength*0.9 or (d&#060;=springLength*0.9 and compressiveness=#rigid) then <BR> set dir to <A HREF="2D vectors.html#dotProd">dotProd</A>(v, velocity2)<BR> if dir&#060;0 and d&#062;springlength then return #bounce<BR> if dir&#062;0 and d&#060;springlength then return #bounce<BR> end if<BR> <BR> -- apply first elastic limit (increased force and damping)<BR> if d&#062;=elasticLimit or d&#060;=minLength or (d&#060;=springLength and compressiveness=#rigid) then <BR> set elasticity to elasticity*20<BR> set damping to max(damping*10,20)<BR> if d&#062;springLength then set springLength to elasticLimit<BR> else if compressiveness=#compressive then set springLength to minLength<BR> end if<BR> <BR> -- calculate force by Hooke's law<BR> set e to d-springlength<BR> set v to v/d<BR> if damping&#062;0 then<BR> set vel to <A HREF="2D vectors.html#component">component</A>(velocity1-velocity2,v)<BR> set f to damping*vel+elasticity*e<BR> else<BR> set f to elasticity*e<BR> end if<BR> return f*v<BR>end <BR><HR></KBD><P><A HREF="math index.html">Back to index</A></PRE></BODY></HTML> 