<HTML><HEAD><TITLE>2D vectors and trigonometry functions</TITLE></HEAD><BODY><H2 ALIGN="center">Functions for cast member "2D vectors and trigonometry" of castlib "math"</H2><P><PRE><KBD><A NAME="arctan"> </A>on arctan (y, x)<BR> --! ARGUMENTS: y, x (numbers)<BR> --! RETURNS: the <A HREF="energy, momentum.html#clockwise">clockwise</A> angle the vector (x,y) makes with the x-axis (in radians)<BR> -- deal with the special cases where x or y are zero<BR> -- NB: we use the Lingo function atan(y, x) in the rest of these functions, since it's identical.<BR> set deg=1<BR> if x=0 and y&#060;0 then set deg to -90<BR> if x=0 and y&#062;=0 then set deg to 90<BR> if y=0 and x&#060;0 then set deg to 180<BR> if y=0 and x&#062;=0 then set deg to 0<BR> if deg&#060;&#062;1 then return deg*pi/180<BR> -- find the basic angle ang=atan(y/x)<BR> set ang to atan(y/float(x))<BR> -- if x is negative and y is positive then add pi to ang<BR> if x&#060;0 and y&#062;0 then return ang+pi<BR> -- if x is negative and y is negative then subtract pi from ang<BR> if x&#060;0 then return ang-pi<BR> -- return ang<BR> return ang<BR>end <BR><HR><A NAME="rotateVector"> </A>on rotatevector p, a, tp<BR> --! ARGUMENTS: p (a 2D vector), a (a number), tp (#radians or #degrees)<BR> --! RETURNS: a new 2D vector rotating p through a degrees or radians. <BR> -- if the angle is zero then return the vector unchanged<BR> if a=0 then return p<BR> -- if tp is undefined then assume the angle to be in degrees if it's an integer, radians if it's a float<BR> if voidp(tp) then<BR> if integerp(a) then tp=#degrees<BR> else tp=#radians<BR> end if<BR> -- if the angle is in degrees then convert it to radians<BR> if tp=#degrees then a=a*pi/180<BR> -- set x and y to the components of p<BR> set x to p&#091;1&#093;<BR> set y to float(p&#091;2&#093;)<BR> -- set l to the magnitude of p<BR> set l to sqrt(x*x+y*y)<BR> -- if l is 0 then return p <BR> if l=0 then return p<BR> -- set newang to a + atan(y,x)<BR> set newang to a+atan(y,x)<BR> -- return the vector l* (cos(newang),sin(newang))<BR> set x1 to l*cos(newang)<BR> set y1 to l*sin(newang)<BR> return point(x1,y1)<BR>end <BR><HR><A NAME="mag"> </A>on mag p<BR> --! ARGUMENTS: p (a 2D vector)<BR> --! RETURNS: the magnitude of p<BR> return sqrt(float(p&#091;1&#093;*p&#091;1&#093;+p&#091;2&#093;*p&#091;2&#093;))<BR>end <BR><HR><A NAME="sqmag"> </A>on sqmag p<BR> --! ARGUMENTS: p (a 2D vector)<BR> --! RETURNS: the squared magnitude of p<BR> return p&#091;1&#093;*p&#091;1&#093;+p&#091;2&#093;*p&#091;2&#093;<BR>end <BR><HR><A NAME="norm"> </A>on norm p<BR> --! ARGUMENTS: p (a 2D vector)<BR> --! RETURNS: the normalized vector of p<BR> m = <A HREF="2D vectors.html#mag">mag</A>(p)<BR> if m=0 then return #error<BR> return p/m<BR>end <BR><HR><A NAME="normalVector"> </A>on normalVector p<BR> --! ARGUMENTS: p (a 2D vector)<BR> --! RETURNS: a vector perpendicular to p<BR> return point(-p&#091;2&#093;,p&#091;1&#093;)<BR>end <BR><HR><A NAME="clockwiseNormal"> </A>on clockwiseNormal p<BR> --! ARGUMENTS: p (a 2D vector)<BR> --! RETURNS: a vector perpendicular to p<BR> return point(-p&#091;2&#093;,p&#091;1&#093;)<BR> -- NB: identical to <A HREF="2D vectors.html#normalVector">normalVector</A>(), but used in specific circumstances<BR>end <BR><HR><A NAME="dotprod"> </A>on dotprod vector1, vector2<BR> --! ARGUMENTS: vector1, vector2 (2D vectors)<BR> --! RETURNS: the dot product of vector1 and vector2<BR> return float(vector1&#091;1&#093;)*vector2&#091;1&#093;+float(vector1&#091;2&#093;)*vector2&#091;2&#093;<BR>end<BR><HR><A NAME="angBetween"> </A>on angBetween vector1, vector2<BR> --! ARGUMENTS: vector1, vector2 (2D vectors)<BR> --! RETURNS: the angle between vector1 and vector2, in radians<BR> -- set m1 and m2 to the magnitudes of vector1 and vector2<BR> set m1 to <A HREF="2D vectors.html#mag">mag</A>(vector1)<BR> set m2 to <A HREF="2D vectors.html#mag">mag</A>(vector2)<BR> -- if either is zero then return #error<BR> if m1=0 or m2=0 then return #error<BR> -- return <A HREF="2D vectors.html#acos">acos</A>(<A HREF="2D vectors.html#dotProd">dotProd</A>(m1,m2)/(m1*m2))<BR> set d to <A HREF="2D vectors.html#dotprod">dotprod</A>(m1,m2)<BR> return <A HREF="2D vectors.html#acos">acos</A>(d/(m1*m2))<BR>end <BR><HR><A NAME="component"> </A>on component vector, <A HREF="2D vectors.html#directionVector">directionVector</A><BR> --! ARGUMENTS: vector, <A HREF="2D vectors.html#directionVector">directionVector</A> (2D vectors)<BR> --! RETURNS: the component of vector in the direction <A HREF="2D vectors.html#directionVector">directionVector</A> (as a scalar)<BR> -- normalize <A HREF="2D vectors.html#directionVector">directionVector</A><BR> set <A HREF="2D vectors.html#directionVector">directionVector</A> to <A HREF="2D vectors.html#norm">norm</A>(<A HREF="2D vectors.html#directionVector">directionVector</A>)<BR> if <A HREF="2D vectors.html#directionVector">directionVector</A>=#error then return #error<BR> -- return <A HREF="2D vectors.html#dotProd">dotProd</A>(vector,<A HREF="2D vectors.html#directionVector">directionVector</A>)<BR> return <A HREF="2D vectors.html#dotProd">dotProd</A>(vector,<A HREF="2D vectors.html#directionVector">directionVector</A>)<BR>end<BR><HR><A NAME="componentVector"> </A>on componentVector vector, <A HREF="2D vectors.html#directionVector">directionVector</A><BR> --! ARGUMENTS: vector, <A HREF="2D vectors.html#directionVector">directionVector</A> (2D vectors)<BR> --! RETURNS: the <A HREF="2D vectors.html#component">component</A> vector of vector in the direction <A HREF="2D vectors.html#directionVector">directionVector</A><BR> -- normalize <A HREF="2D vectors.html#directionVector">directionVector</A><BR> set <A HREF="2D vectors.html#directionVector">directionVector</A> to <A HREF="2D vectors.html#norm">norm</A>(<A HREF="2D vectors.html#directionVector">directionVector</A>)<BR> if <A HREF="2D vectors.html#directionVector">directionVector</A>=#error then return #error<BR> -- return <A HREF="2D vectors.html#dotProd">dotProd</A>(vector,<A HREF="2D vectors.html#directionVector">directionVector</A>)<BR> return <A HREF="2D vectors.html#dotProd">dotProd</A>(vector, <A HREF="2D vectors.html#directionVector">directionVector</A>)*<A HREF="2D vectors.html#directionVector">directionVector</A><BR>end<BR><HR><A NAME="switchbasis"> </A>on switchbasis vector, <A HREF="2D vectors.html#directionVector">directionVector</A><BR> --! ARGUMENTS: vector, <A HREF="2D vectors.html#directionVector">directionVector</A> (2D vectors)<BR> --! RETURNS: the components of vector in a basis with <A HREF="2D vectors.html#directionVector">directionVector</A> as one basis vector, <BR> --! along with the basis vectors themselves<BR> -- find the two basis vectors basis1 and basis2<BR> set basis1 to <A HREF="2D vectors.html#norm">norm</A>(<A HREF="2D vectors.html#directionVector">directionVector</A>)<BR> if <A HREF="2D vectors.html#directionVector">directionVector</A>=#error then return #error<BR> set basis2 to <A HREF="2D vectors.html#normalVector">normalVector</A>(basis1)<BR> -- set a and b to the dot products of vector with basis1 and basis2<BR> set a to <A HREF="2D vectors.html#dotProd">dotProd</A>(vector, basis1)<BR> set b to <A HREF="2D vectors.html#dotProd">dotProd</A>(vector, basis2)<BR> return &#091;a, b, basis1, basis2&#093;<BR>end<BR><HR><A NAME="acos"> </A>on acos x<BR> --! ARGUMENTS: x (a number)<BR> --! RETURNS: acos(x) in radians<BR> if x&#062;1 or x&#060;-1 then return #error<BR> return atan(sqrt(1-x*x),x)<BR>end<BR><HR><A NAME="asin"> </A>on asin x<BR> --! ARGUMENTS: x (a number)<BR> --! RETURNS: asin(x) in radians<BR> if x&#062;1 or x&#060;-1 then return #error<BR> return atan(x,sqrt(1-x*x))<BR>end<BR><HR><A NAME="clockwiseAngle"> </A>on clockwiseangle vector1, vector2<BR> --! ARGUMENTS: vector1, vector2 (2D vectors)<BR> --! RETURNS: the <A HREF="energy, momentum.html#clockwise">clockwise</A> angle between vector1 and vector2, in the range -pi to pi<BR> -- set a1 and a2 to the angles of vector1 and vector2<BR> set a1 to <A HREF="2D vectors.html#angleof">angleof</A>(vector1)<BR> set a2 to <A HREF="2D vectors.html#angleof">angleof</A>(vector2)<BR> -- set a to the angle between them<BR> set a to a2-a1<BR> -- constrain to the correct range and return a<BR> if a&#062;pi then set a to a-2*pi<BR> if a&#060;-pi then set a to a+2*pi<BR> return a<BR> <BR>end<BR><HR><A NAME="directionVector"> </A>on directionVector ang, unit<BR> --! ARGUMENTS: ang (in radians or degrees), unit (#degrees if you want degrees)<BR> --! RETURNS: a 2D vector pointing at ang <A HREF="energy, momentum.html#clockwise">clockwise</A> from the positive x-axis<BR> if unit=#degrees then set ang to ang*pi/180<BR> return point(cos(ang),sin(ang))<BR>end<BR><HR><A NAME="angleOf"> </A>on angleOf vect, unit<BR> --! ARGUMENTS: vect (2D vector), unit (#degrees if you want degrees)<BR> --! RETURNS: the <A HREF="energy, momentum.html#clockwise">clockwise</A> angle unit makes with the positive x-axis, in the range -pi to pi<BR> ang=atan(vect&#091;2&#093;,vect&#091;1&#093;)<BR> if unit=#degrees then ang=ang*180/pi<BR> return ang<BR>end<BR><HR><A NAME="constrainangle"> </A>on constrainangle ang, range, unit<BR> --! ARGUMENTS: ang (in radians), range (minimum value of range), unit (#degrees for degrees)<BR> --! RETURNS: the angle constrained to &#091;range,range+2pi)<BR> if voidp(range) then range=0<BR> if unit=#degrees then offs=360<BR> else offs=2*pi<BR> <BR> repeat while ang&#060;=range<BR> set ang to ang+offs<BR> end repeat<BR> repeat while ang&#062;range+offs<BR> set ang to ang-offs<BR> end repeat<BR> return ang<BR>end<BR><HR></KBD><P><A HREF="math index.html">Back to index</A></PRE></BODY></HTML> 